### HashMap

是什么  
数据结构  
特点   
部分原理   
相关问题

#### 1、是什么
HashMap是基于哈希表的 Map 接口的非同步实现的一种特殊集合。以key-value形式存储数据，允许存在null值和null键,有很快
的访问速度，但是取出的数据的顺序是随机的。

#### 2、数据结构
数组+链表+红黑树(1.8才有)

#### 3、特点
* HashMap是基于哈希表的Map实现。
* HashMap底层数据结构是数组(1.7)和链表实现，后来增加了红黑树(1.8)。
* HashMap是采用key-value形式存储，key是可以为null，但是只能有一个，key不能重复。
* HashMap保存数据的顺序和访问顺序可能是不一样的。
* HashMap是线程不安全的。

#### 4、部分原理

##### HashMap的原理
> HashMap是基于数组+链表结构设计。数组中的每个元素都是一条链表的表头。数组默认长度为16。添加元素时，根据key的hash
> 值与数组长度-1的差做与运算，得到元素在数组中的位置。如果数组对应索引存在元素并且它们的hash值不一样，就将新元素添加到后
> 面(尾插法，jdk1.7是头插法)成为该链表的一个新节点。jdk1.8后，引入红黑树，当hash数组的容量大于64且链表长度大于8时，
> 链表转红黑树；当长度小于6的时，红黑树转链表。


##### HashMap中get()、put()如何实现的
put：
> 1、计算key的hash值；   
> 2、计算key在数组中的索引(hash&(arr.length-1)；   
> 3、如果当前索引对应的数组元素为null，直接在该索引上，充当链表头几点；如果不为null，比较key的hash值或者equals，
> 有一个不同时将新元素插入到链表成为新节点；如果都hash值跟equals都相等，替换value。

get:
> 1、计算key的hash值；   
> 2、计算key在数组中的索引(hash&(arr.length-1)；    
> 3、key的hash值判断，如果是链表头节点则返回头结点；如果不是，判断表头节点是否属于红黑树。如果是，遍历红黑树查找
> 到目标，否则遍历链表找到指定元素。

##### HashMap和HashTable的区别。
--  |  HashMap  |   HashTable
:--- | :--- | :----
多线程问题 | 线程不安全、效率高 | 线程安全、效率低
底层结构 |  数组+链表 + 红黑树(jdk1.8后) | 数组+链表
扩容方面 | 初始容量大小为16，扩容后变为原来的2倍 | 初始容量大小为11，扩容后会变为2n+1
继承关系 | AbstractMap | Dictionary(被废弃)


#### 5、相关问题

##### HashTable为何废弃
> 线程安全形成效率低下；HashTable继承的父类也是被废弃了。

##### HashMap 的扩容因子为什么是0.75?
> 大概是根据空间与时间的权衡效果吧(泊松分布了解一下，默认容量是16，在12的情况下是最优的)

##### HashMap和ConcurrentHashMap的区别
> 最大区别就是HashMap线程不安全、ConcurrentHashMap线程安全。

##### hashmap扩容是怎么做的，怎么处理hash冲突
> 当元素数量超过阈值时便会触发扩容。每次扩容的容量都是之前容量的2倍。[阈值 = 数组容量 * 负载因子]。默认初始容量为16，
> 负载因子为0.75。

解决hash冲突(Hashmap如何解决散列碰撞)：
> 1、链式地址法。在冲突的位置拉一个链表，把冲突的元素放进去。(数组+链表结构)
> 2、扰动函数。(hash函数[哈希值的高16位^哈希值的低16位])。(从哈希值入手，尽可能保证哈希值不一样)
> 3、引入红黑树。(优化Hash表链表过长导致时间复杂度增加)
> 4、再Hash法(未使用)。利用多个hash函数，遇到冲突时就使用其他hash函数计算，直到不冲突。(缺点：计算时长增加)

##### 当两个对象的hashCode相等时会怎样
> 发生哈希冲突，若key值内容相同则替换旧的value，否则添加到链表后面，当链表长度超过阈值8，并且数组长度大于64就转为
> 红黑树存储。

##### hashmap扩容会有什么问题吗
> 链表可能会出现死循环。原因：多线程环境 + 链表头插法(jdk1.7为头插法，1.8后变成尾插法)
> <https://www.cnblogs.com/zhuoqingsen/p/8577646.html>

##### HashMap查找的时间复杂度是多少？
> 找表头元素是O(1)，因为数组的索引指定查找；链表时O(n)，红黑树时O(logN)

##### 为什么HashMap初始大小是2的次幂，对扩容有没有影响
> 能够满足位运算提高效率。(hash值很大，数组长度相对较小，需要取余才能作为数组下标，而位运算代替取余效率会很高)；     
> 打乱key的hash值[右移+异或]后在进行[&运算]能得到更平均的数组索引。(尽可能的将集合元素分配到数组的不同位置上，
> 减少哈希碰撞)。

> 扩容时扩大为原来长度的2倍，长度始终保持是2的n次幂。

##### HashMap的数据结构,如何保证快速查找。
> jdk1.7 数组+链表；jdk1.8 数组+链表+红黑树。当链表节点数量少时，查询时间较快；当链表节点多时，链表转红黑树。当红
> 黑树节点又变少时，红黑树转链表。

##### Hashmap底层为什么是线程不安全的
> 因为它的put方法无法保证原子性以及可见性。导致在多线程环境下扩容时会发生死循环(链表成环)，djk1.8会数据覆盖。

##### 解决hash冲突的时候，为什么用红黑树
> 当HashMap的key冲突过多时，会导致链表过长，此时链表的查询效率很差，引入红黑树优化查询效率，空间换时间。

##### 红黑树的效率高，为什么一开始不用红黑树存储
> 因为红黑树的节点比链表节点大(2倍)，占用空间更大，而且链表比较短的时候查询也足够快，没必要直接使用红黑树的结构。

##### 为什么阀值是8才转为红黑树
> 8其实是一个预估值。和hashcode碰撞次数的泊松分布有关，产生8次碰撞的几率为0.00000006，比千万分之一还小的概率。正
> 常情况下不会存储这么多数据，hashCode分布比较良好，数据分布也比较均匀，很少出现链表很长的情况。出于对时间和空间平衡
> 的选择结果。

##### 为什么退化为链表的阈值是6
> 如果退化阈值也设置为8，那么可能会出现链表和红黑树的不停相互转换，浪费资源；中间留下个差值7可以防止链表和树之间的
> 频繁转换。