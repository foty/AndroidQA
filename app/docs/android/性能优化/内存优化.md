### 内存优化

* 内存泄露
* 内存抖动
* 内存碎片


#### 前提知识 -- JVM

##### jvm内存模型
> 程序计数器、虚拟机栈、本地方法栈、方法区、堆;  

##### GC如何确定内存回收
> 引用计算算法
> 可达性分析算法

##### 引用类型
> 强引用：
> 软引用：内存不足会自动回收。(部分后台数据可以使用软引用)
> 弱引用：GC时会回收
> 虚引用：不会影响对象的生命周期，主要跟踪GC。但是能让开发者知道对象什么时候回收了。

#### 内存泄露

内存泄露产生原因
> 长生命周期对象持有端生命周期对象引用。

解决办法：
> 通过工具分析，断开引用链。如果是第三方框架或者系统方面，使用反射置空。


##### 内存抖动

产生原因： 频繁分配和回收内存。

比如：使用StringBuffer替换字符串的 `+=`；WebView Activity单开新进程处理。

##### 良好编程习惯实现内存优化

- 枚举优化。(使用静态对象+注解优化)
- static与static final。(static final 速度更快，不需要初始化，直接打包进dex文件，直接用)
- 字符串少用+连接。
- 重复创建对象。(如在递归中new对象，使用对象池)


##### bitmap内存管理 (参考glide框架内存管理)

图片缓存(3级缓存)
> 内存缓存(lruCache+缓存池/复用池+弱引用队列(比自动GC快))
> 磁盘缓存

质量取决于图片在内存中的格式：
ALPHA_8：代表像素只有透明度信息，没有颜色信息。一个像素占 8 bit，即 1 Byte。
RGB_565：代表像素只有颜色信息，没有透明度信息。其中R占用5bit，G占用6bit，B占用5bit。一个像素大小为：5+6+5=16bit ，即2 Byte。
ARGB_4444：代表像素既有透明度信息，也有颜色信息。其中A占用4bit，R占用4bit，G占用4bit，B占用4bit。一个像素大小为4+4+4+4=16bit，即2Byte。
ARGB_8888：代表像素既有透明度信息，也有颜色信息。其中A占用8bit，R占用8bit，G占用8bit，B占用8bit。一个像素大小为8+8+8+8=32bit，即4Byte。
