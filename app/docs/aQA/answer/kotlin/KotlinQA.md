###

kotlin知识点： [](../../../kotlin/Kotlin基础.md)



##### Kotlin中注解 @JvmOverloads的作用
> 添加@JvmOverloads注解会暴露多个重载方法，减少写构造方法。比如有一个3个参数的方法，添加此注解后会暴露出1个参数、2个参
> 数、3个参数的3个方法(重载方法)。不添加就只有一个(匹配当前参数)方法。

##### Kotlin中的MutableList与List有什么区别
一个是不可变(只读)集合，一个是可变集合。
> List：有序接口，只能读取，不能更改元素；   
> MutableList：有序接口，可以读写与更改、删除、增加元素。

##### 委托属性
> by lazy

##### init初始化代码块
> kotlin中若存在主构造函数，其不能有代码块执行，init起到类似作用，在类初始化时侯执行相关 的代码块。
init代码块优先于次级构造函数中的代码块执行。即使在类的继承体系中，各自的init也是优先于构造函数执行。
在主构造函数中，形参加有var/val，那么就变成了成员属性的声明。这些属性声明是早于init代码块的。

##### 用var和val声明变量有什么区别
> var是可变变量，val是不可变变量，只能赋值一次。

##### Kotlin中的数据类型有隐式转换吗？为什么？
> 没有。

##### 用val和const声明变量有什么区别
> val与const都是不可变的。但是const变量的值必须在编译时确定，而val变量的值也可以在运行时分配。

##### 安全调用(?.)和空值检查(!!)有什么区别
> ?.用于检查变量的值是否为空。如果为 null 则返回 null ，否则返回所需的值。!!会在变量值为 null 时抛出空指针异常。

##### @JvmStatic、@JvmOverloads、@JvmFiled 在 Kotlin 中有什么用？
> @JvmStatic：这个注解用来告诉编译器该方法是静态方法，可以在Java代码中使用。   
@JvmOverloads：要在Java代码中使用Kotlin代码中作为参数传递的默认值，我们需要使用@JvmOverloads注解。
@JvmField：要在不使用任何getter和setter的情况下从Java代码访问Kotlin类的字段，我们需要@JvmField在Kotlin代码中使用。

##### Kotlin 中的 lateinit 和 lazy 有什么区别
> lazy 只能用于val属性(不可变)，而 lateinit 只能用于 var，并且不能用在可空的变量上。

##### ==操作符和===操作符有什么区别
> ==运算符用于比较变量中存储的值，运算===符用于检查变量的引用是否相等。但是在原始类型的情况下，===操作符也会检查值而
> 不是引用。

##### Kotlin 中的伴生对象是什么
> 使用companion修饰。作用是能在没有类实例的情况下调用的类成员或者方法。类似java中的静态类，静态方法。

##### Kotlin 中的高阶函数是什么
> 高阶函数是将函数作为参数或返回函数的函数。例如，函数可以将函数作为参数。

##### Kotlin 中的 open 关键字是做什么用的
> 让类或者函数能够被继承或者覆盖。默认情况下，类和函数在Kotlin中是最终的。不能继承类或覆盖函数。

##### Kotlin 中的具体化类型是什么
> reified修饰。当使用泛型将某个类作为参数传递给某个函数并且需要访问该类的类型时，需要使用reified关键字修饰。

##### 什么是 lambdas 表达式
> Lambdas表达式是可以被视为值的匿名函数，可以将lambdas表达式作为参数传递给函数返回。

##### Kotlin中的扩展函数是什么
> 扩展函数就像附加到Kotlin中的任何类的扩展属性或方法。即使不继承该类，也可以向现有类添加一些方法或功能。

##### Kotlin 中的中缀函数是什么
> 使用infix修饰。中缀函数可以在不使用任何括号或括号的情况下调用该函数。但是需要使用中缀关键字才能使用中缀功能。

##### Kotlin中的内联函数是什么
> 内联函数指示编译器在代码中使用该函数的任何位置插入完整的函数体。需要添加inline关键字修饰。

##### 什么是密封类
> 密封类是子类有限的类，使用使用 sealed 修饰。它构造器默认就是private的，且不可修改。类似枚举。跟枚举不同的是：
> 枚举：实例可数，没有子类。   
> 密封类：子类可数，有子类。

##### 使用密封类而不是枚举有什么好处？
> 密封类提供了拥有不同类型的子类并包含状态的灵活性。需要注意的是扩展Sealed类的子类应该是Sealed类的嵌套类，或者应该在
> 与Sealed类相同的文件中声明。

##### Kotlin内置标准函数let、run的原理是什么
> 1、标准let内置函数内部对泛型进行了let函数扩展，意味着所有的类型都等于泛型，所以任何地方都是可以使用let函数的；
> 2、所有类型let其实是一个匿名的Lambda表达式。Lambda表达式的特点是：最后一行会自动被认为是返回值类型。所以在表达式
> 返回Boolean，那么当前的let函数就是Boolean类型。

#####  Kotlin 中 let、run、with、also 和 apply 的区别 。
函数名称 | 函数体特指对象    | 返回值 | 适合场景
:--- |:-----------| :--- |:---
let | it指当前对象    | 函数块的最后一行或指定return表达式(闭包) | 多数用于处理不为null的操作场景
with | this指代当前对象 | 函数块的最后一行或指定return表达式(闭包) | 调用同个对象的多个方法或属性时，可以省略对象
run | this指代当前对象 | 函数块的最后一行或指定return表达式(闭包) | 适用于let、with函数的任何场景
apply | this指代当前对象 | 传入对象本身(this)                  | 对象实例初始化时，对对象的属性进行赋值
also | it指代当前对象   | 传入对象本身(this)                   | 适用于let函数的任何场景(用的少)


##### kotlin是什么,特点
> kotlin是一门编程语言。和java一样，最后的编译结果都是.class文件(字节码)，运行在JVM上。特点就是简洁，安全，高效。支
> 持面向对象和函数式编程。   
> 空安全，函数式编程

##### Kotlin 中的协程是什么
> 1、一个以高效和简单的方式管理并发的框架，线程框架或者并发设计模式。特点就是能够以阻塞(同步)方式写出非阻塞(异步)的
> 代码。       
> 2、核心就是一段程序能够被挂起，并在稍后再在挂起的位置恢复。其实也是“接口回调”的特殊形式。挂起和恢复依赖于内部状态机实
> 现。协程是依赖于线程池API的，在一个线程可以创建多个协程，并且协程运行时并不会阻塞当前线程。所以也有协程是一个轻量级线
> 程框架的说法。     
> 3、使用 launch与async来创建、启动协程。

##### 协程与线程有什么区别？有哪些优点？
> 在单个进程内，多个协程串行执行，只挂起不阻塞，协程最终的执行还是在各个线程之中。  
优点：
写法简便，能够以同步的形式写出异步的代码，避免回调地狱。

##### 什么是协程？
> 1、一个以高效和简单的方式管理并发的框架，线程框架或者并发设计模式。特点就是能够以阻塞(同步)方式写出非阻塞(异步)的代码。       
> 2、核心就是一段程序能够被挂起，并在稍后再在挂起的位置恢复。其实也是“接口回调”的特殊形式。挂起和恢复依赖于内部状态机实
> 现。协程是依赖于线程池API的，在一个线程可以创建多个协程，并且协程运行时并不会阻塞当前线程。所以也有协程是一个轻量级线
> 程框架的说法。     
> 3、使用 launch与async来创建、启动协程。

##### 协程的原理
> 挂起函数。其实也是`接口回调`的特殊形式。挂起和恢复依赖于内部状态机实现。协程是依赖于线程池API的，在一个线程可以创建多个
> 协程，并且协程运行时并不会阻塞当前线程。所以也有协程是一个轻量级线程框架的说法。   


##### Kotlin语言泛型的形变是什么？
> 形变一共分为三个：不变，协变，逆变。
> 不变：可以是生产者，也可以是消费者，此泛型没有任何泛型继承相关的概。
> 协变：只能是生产者。此泛型有泛型继承相关的概念存在。表示可以接收此泛型类型的子类型，使用`out`标识；
> 逆变：只能是消费者，此泛型有泛型父类转子类的强转相关的概念存在。表示可以接收此泛型类型的父类型，使用`in`标识