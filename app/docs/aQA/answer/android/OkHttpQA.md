
* 源码分系： [](../../../third_frame/OkHttp3.md)


##### okhttp基本流程
> 1、通过OkhttpClient创立一个Call，并发起同步或者异步请求；
> 2、okhttp会通过Dispatcher对我们所有的RealCall(Call的具体实现类)请求进行统一管理，选择同步或者异步请求进行处理；
> 3、同步请求会加入到同步队列中执行，异步请求会加入到异步队列中请求；
> 4、经过5个拦截链后得到响应数据，返回给调用者。

##### OkHttp的基本实现原理
> 通过5个拦截器，3个双端队列(2个异步队列，一个同步队列)，结合责任链模式共同实现，将网络请求的各个阶段封装到各个链条中，实现每个层次的解耦。  
> 请求底层：通过socket发送http请求与接收响应。okHttp实现了连接池的概念，也就是同一个主机的多个请求。可以公用一个socket连接，而不是每次发送
> 完http请求就关闭底层socket。

##### OkHttp中有几级请求队列，分别的意义是什么
> 3个。2个异步队列，1个同步队列。分别代表正在执行异步队列，等待异步队列，正在执行同步队列。

##### okHttp同时支持多少个主机，每个主机请求数目是多少
> 5个主机。最大并发数量是64(正在请求队列设置的上限)

##### 为什么设置3级队列(2个异步队列、一个同步队列)
> 如果只有一个队列，当某个请求发生错误，需要将这个请求重新排序。如果队列内请求数量非常庞大，将非常损耗性能。所以需要设置一
> 个大小固定(为64)的一级队列，也就是正在执行异步队列，能支持更多的数据请求，容量是无限的二级队列，也就是等待异步队列。最
> 后使用一个同步队列来存放失败的请求。同步队列的请求会重新回到二级队列中，最后放到一级队列重新请求，这样避免了重新排序，又
> 提高效率。

##### okhttp运用了哪些设计模式
> 责任链模式(拦截器)、工厂模式(创建call对象)、单例模式、策略模式(选择缓存数据还是请求数据)。

##### okhttp有没有保留线程
> 没有。(线程池没有核心线程)

##### okhttp为什么使用socket而不是用HttpURLConnection
> HttpURLConnection好处是可以请求任何一台服务器，缺点是每次请求需要3次握手，影响效率。而通过socket实现连接池复用，
> 请求只需要经过一个3次握手即可。效率非常高，缺点是请求服务器有限。

##### 有哪些拦截器，作用是什么
> 重定向拦截器: 错误重试机制
> 桥接拦截器：构建请求头
> 缓存拦截器：从缓存中获取或者从服务器重新获取
> 连接拦截器：维护连接池，负责连接复用、创建连接(3次握手)、释放连接、创建socket流。
> 网络拦截器：真正执行网络请求，获取数据。

##### 为什么设置拦截器
> 将网络请求的各个阶段封装到各个链条中，实现每个层次的解耦。

##### okhttp如何实现连接复用，为什么可以做连接池
> 维护了一个连接池。在请求之前首先从连接池获取连接，如果存在就不创建，否则新建连接。okhttp使用socket连接，让同一个主
> 机的多个请求。可以公用一个socket连接，而不是每次发送完http请求就关闭底层socket。这就是连接池。

##### okhttp在连接问题怎么自动恢复
> 失败重连?连接池。

##### Dispatcher作用是什么
> 分发请求，选择同步还是异步。

##### okhttp中socket如何请求数据
> 通过直接连接或者隧道建立连接，发送http协议，通过Okio方法获取资源。