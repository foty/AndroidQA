
###
* http、https、dns
* tcp/udp (3次握手，4次挥手)
* 网络模型

知识点内容 [](../../../http/net.md)


##### 网络如何分层的?5层分别是啥?为啥要做5层分层?每层都分别干啥事情?
> 分应用层、传输层、网络层、链路(网络接口)层、物理层。

##### 计算机中的网络模型有几层
> 应用层：应用程序与网络的接口，提供网络服务。常见的协议有HTTP、HTTPS、FTP。
> 传输层：主机中进程到进程之间的相互通信。常见的协议有TCP、UDP等;
> 网络层：主机到主机之间的相互通信。常见的协议有：IP(IPV4 IPV6)、ICMP、IGMP、 ARP、RARP等;
> 数据链路层：处理网络层与物理层之间的通信。通过数据帧来传输;
> 物理层：硬件设备等;

##### 怎么判断弱网环境，然后怎么处理弱网情况
> 加大超时时间，自动重试，复合链接

##### dns优化和缓存
> 优化：IP直连、使用HttpDns

##### DNS有啥缺点?为啥国内要用HttpDNS?
> 缺点：不稳定、不准确、不及时。HttpDNS对比传统DNS具有域名防劫持、精准调度等特点，更安全、更稳定。

##### 谈谈你对Http的post与get请求区别的理解？
> post请求更加安全，不会把参数放到url中，不会被缓存。get请求如果是数据会被缓存；
> get请求的url长度有限制，post请求没有；
> get请求参数放在url中，post请求参数放在request body中；

##### 断点续传原理？
> 通过Range头和Content-Range头来实现。客户端在请求中指定Range头，指示从何处开始下载，服务器则在其响应中包
> 含Content-Range头

##### 如何保证下载文件的完整性
> 1、使用https；2、使用校验。如md5，sha1值等等；3、对下载资源访问。只有安全完整的下载资源才能正常访问。等等

##### DNS是什么
> DNS，即域名系统(DomainNameSystem)，就是进行域名解析的服务器。保存域名和IP地址相互映射数据。

##### 输入一串URL到浏览器都经历过什么?
> 客户端(浏览器)发起一个网络请求时，首先就是要经过DNS服务，也就是域名解析，将域名转化为IP地址，然后通过IP地址建立连接。

域名解析过程：
> 依次从 本地缓存解析-> 本地DNS服务器解析-> 根域名服务器解析-> 顶级域名服务器-> 权威域名服务器，获取ip地址。建立TCP连接

##### Http1.0 vs Http1.1区别
> 缓存策略，http1.1引入了更多缓存策略，如Entity tag、If-Match等缓存头。  
> http1.1增加了[range]头域，可以请求部分资源。  
> 长连接，http1.1支持长连接处理；

##### http2.0 vs http1.x区别
> 多路复用(连接共享)
> header压缩
> 二进制分帧，全新的二进制传输格式
<https://juejin.cn/post/6844903489596833800>

##### http3.0?
> 基于QUIC的新协议

##### Http & Https的区别?
> http是超文本传输协议，信息是明文传输；https则是具有安全性的ssl加密传输协议;  
> http不需要证书，https需要证书；
> http和https使用的是完全不同的连接方式，用的端口也不一样，http是80,https是443。  
> http的连接很简单,是无状态的，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

##### 为啥要用Https?
> Https能提供对网站服务器的身份 认证，保护交换数据的隐私与完整性。比起Http更加安全。

##### SSL是什么，TLS
> SSL即 Secure Socket Layer，翻译为安全套接层协议；TLS，即transport layer security，翻译为安全传输层协议。
> TLS是SSL改名而来，SSL与TLS是同一种东西的不同阶段体现。

##### SSL握手的过程都经历过什么
> 第一阶段：客户端发起建立连接请求。并把协议版本信息，加密方法等发送给服务端；  
> 第二阶段：服务端响应客户端3个报文。确认协议，加密方法，将服务器证书，公钥发送客户端；  
> 第三阶段：客户端认证和密钥交换。客户端验证服务端证书是否合法，然后用证书加密发送服务端；  
> 第四阶段：服务端解密。服务端用已知的加解密方法获得连接会话秘钥，最后通知客户端秘钥确认，TLS握手结束。

https://blog.csdn.net/Mind_programmonkey/article/details/118380707

##### TCP的三次握手是怎样的过程?
> 指服务端与客户端建立联系传输数据前的3次交互。
* 第一次握手：建立连接时，客户端向服务端发送SYN包，然后进入SYN_SEND状态，等待服务端确认；
* 第二次握手：服务端收到客户端的请求后，返回一个确认信息ACK，同时发送SYN包，服务端进入SYN_RECV状态
* 第三次握手：客户端收到服务端的ACK+SYN后，向服务端发送ACK。发送完毕后，客户端与服务端都进入ESTABLISHED(TCP连接成功)状态，完成三次握手。

##### 说说TCP的4次挥手
> 指客户端与服务端准备断开TCP连接时，需要的4次交互
* 第一次挥手：客户端向服务端发送一个FIN包，然后客户端进入FIN_WAIT状态;
* 第二次挥手：服务端收到客户端发送的FIN后，发送一个ACK给客户端，然后进入CLOSE-WAIT状态(关闭等待);
* 第三次挥手：服务端向客户端发送一个FIN包，服务端进入LAST-ACK(最后确认)状态;
* 第四次挥手：客户端收到服务端的FIN后，客户端进入TIME_WAIT(倒计时)状态，然后向服务端发送一个ACK。服务端收到后进入CLOSED状态，完成4次挥
手。客户端的TIME_WAIT状态会持续2msl(最长报文段寿命时间)，然后进入CLOSED状态。

##### 为什么需要三次握手?两次会有什么问题?
> 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。     
> 举个例子。客户端发出一个请求，这个请求因为网络节点长时间滞留导致客户端已经取消连接了才到达服务端。此时对于客户端来说，这是一个失效的连
> 接请求。假如不是使用3次握手，服务端收到请求后，同意连接，向客户端发送确认ACK，并等待客户端确认。但此时客户端并没有发出连接请求，所
> 以不会回应服务端。服务端的资源会被白白浪费。

##### 为什么需要四次挥手?两次行不行?
> 保证数据传输完整性。  
> 关闭连接时，服务器收到客户端的FIN报文时，仅仅表示客户端不再发送数据了但是还能接收数据；并且服务端收到客户端的FIN，发送一个ACK后，仅仅代表服务端知道了
> 客户端没有数据发送了，但是服务端还可以发送数据给客户端。所以服务端可以选择关闭，也可以选择继续发送完数据给对方后，再发送FIN包给客户端来表示现在可以关闭
> 连接，因此，服务端的ACK和FIN一般都会分开发送。客户端收到服务端的FIN包也需要响应一个ACK告知服务端，客户端已确认。此时客户端与服务端都完成关闭确认，保
> 证数据传输完整。

##### 为什么客户端最后还要等待2MSL?
> 1、为了保证服务端能收到客户端的确认应答，若客户端发完确认ACK后直接进入CLOSED状态，那么如果该ACK丢失，服务端等待超时后就会重新发送连接释放
> 请求，但此时客户端已经关闭，不会作出任何响应，因此服务端就无法正常关闭。2、保证这次连接的重复数据段从网络中消失。

##### 谈谈你对TCP与UDP的区别是什么
> TCP可靠、面向连接、效率低，传输慢；UDP不可靠、无连接、效率高、传输快；

应用场景：
> TCP需要精准，对效率要求没那么高，如：邮件传输、文件传输等等；
> UDP需要在速度快、效率高的场景，如音视频通话、流媒体服务、域名解析等等

##### 如何基于UDP协议实现可靠传输?
> quic。
<https://www.jianshu.com/p/8f0b8d0a4832>

##### 谈谈你对TCP流量控制与拥塞控制的理解
`拥塞控制`和`流量控制`是TCP用来解决传输数据中产生的问题采取的两种优化方法。   
https://blog.csdn.net/deng1456694385/article/details/88855269  

流量控制
> 是为了解决发送方和接收方速度不同而导致的数据丢失问题。当发送方发送的太快，接收方来不及接受就会导致数据丢失。
> 流量控制使用`滑动窗口`的形式处理。

窗口
> 窗口就是缓冲区，用来暂时存储数据等待发送和接收，也就是对每次发送的数据大小进行限制。每个窗口的都有大小限制，超过部分不能
> 发送，可以不用每次发送报文等待ACK确认，只要保证发送的报文再发送窗口内部就行。
> 优点：消除等待确认的时间，大大提高效率。

拥塞控制
> 是为了解决过多的数据注入到网络，导致网络奔溃，超过负荷。当发送方发送数据大量的数据会注入到网络，如果没有限制，网络就会超
> 负荷变卡。
> 具体包括4个策略：慢开始、拥塞避免、快重传、快恢复。

慢开始
> 就是窗口预先设置较小，随着传输轮次大小逐渐增长，直到到达最大值。这个阶段就是慢开始；

拥塞避免
> 窗口随着传输轮次数量增加，直到触发了网络拥塞。这时将窗口数量与窗口大小变为拥塞时的一半，然后从新慢开始。

快重传
> 当接受方收到顺序错误数据时，重新发起对之前数据的确认。发送3次后，发送方得知自己部分数据丢失，立即发起重传，不需要等待下一次
> 发送信息时一起发送过去。且重传时触发和拥塞一样得情况。进入快恢复阶段。

快恢复
> 再次发生拥塞和重传时，窗口经历了拥塞避免阶段，然后进入快恢复阶段。和拥塞避免一样都是逐渐增加。这样能提高恢复速度，像老版
> 本(Tahoe)中需要重新经历慢开始。