###

知识点： 知识点： [](../../../java/泛型.md)

##### 泛型是什么
> 泛型的本质是参数化类型，把数据类型当作是参数一样传递。

##### 你了解泛型通配符与上下界吗?
> 泛型上下界就是上限通配符与下界通配符，目的都是为了让泛型使用更加方便灵活。如`extend T`，T为上界(生产者)，接受T或者T的子类类型；`super T`，T
> 为下界(消费者)，接受T或者T的父类类型，

##### 泛型类的继承
> 1、全部继承；2、部分继承；3、全部实现；4、忽略泛型。

##### 泛型擦除是怎么回事?
> (问概念) 泛型擦除指在编译阶段，所有的泛型会被替换成相应的原始类型，使得使用泛型的代码可以和没有使用泛型的代码随意互用。

##### 数组中能不能使用泛型?
> 不能

##### 原始类型和带参数类型之间的主要区别?
> 在编译时编译器不会对原始类型进行类型安全检查，却会对带参数的类型进行检查。

##### 如果擦除了，那运行时是怎么拿回原来的类型的?
> 编译时，编译器在泛型擦除位置做上标记(保存)，并在后续的使用中增加类型安全检查或者类型强制转换。

##### Gson是怎么处理的泛型擦除?
> 使用TypeToken匿名类。通过子类继承父类并实现父类的泛型，从而保存下来具体的泛型类型。

##### 泛型常用特点，泛型有什么优点
> 性能高。存储值类型或转换为值类型时不需要装箱和拆箱；  
> 代码简洁方便。内部的转换都是自动和隐式的，省略强制转换代码；
> 类型安全。编码时限定了类型，只要编译时期没有警告，运行时就不会抛出类型转换异常，把运行时的问题提前到编译时期。

##### List<String>能否转为List<Object>
> 不行。因为泛型存在类型擦除，在编译后都会变成List，无法区分。还有String是Object的子类型，但是List<String>不是
> List<Object>的子类型，二者无法直接转换。

##### 泛型是怎么解析的，比如在retrofit中的泛型是怎么解析的
> Gson[GsonConverterFactory]

##### 泛型为什么要擦除？泛型的pecs原则
> 为了向后兼容，让使用泛型的代码可以和没有使用泛型的代码随意互用。

PECS：
> 要从泛型类取数据时，用extends;   
> 要往泛型类写数据时，用super;    
> 既要取又要写，就不用通配符(即extends与super都不用)。

##### 为何会有协变和逆变
> java泛型是不变的。但是为了让泛型能变的像普通类一样具有继承关系。实现逆变与协变，就是利用通配符?。

##### 通配符
泛型的通配符是用于`解决泛型之间引用传递问题的特殊语法`, 在逻辑上还原了泛型类传入数据类型的参数父类子类的继承关系，同时
也可以按照需求设定通配符的上限与下限。
> 无边界通配符，写作`?`，表示可以是任何类型；    
> 固定上边界通配符，写作`? extend T`，表示必须是T或者T的子类类型；   
> 固定下边界通配符，写作 `? super T`，表示必须是T或者T的超类(父类)   