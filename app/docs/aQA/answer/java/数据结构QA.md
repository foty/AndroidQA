### 

* 集合      [](../../../data_structure/集合.md)
* HashMap 扩容，原理，底层       [](../../../data_structure/HashMap.md)
* ArrayList   [](../../../data_structure/ArrayList.md)


##### HashTable为何废弃
> 线程安全形成效率低下；HashTable继承的父类也是被废弃了。

##### HashMap 的扩容因子为什么是0.75?
> 大概是根据空间与时间的权衡效果吧(泊松分布了解一下，默认容量是16，在12的情况下是最优的)

##### HashMap和ConcurrentHashMap的区别
> 最大区别就是HashMap线程不安全、ConcurrentHashMap线程安全。

##### hashmap扩容是怎么做的，怎么处理hash冲突
> 当元素数量超过阈值时便会触发扩容。每次扩容的容量都是之前容量的2倍。[阈值 = 数组容量 * 负载因子]。默认初始容量为16，
> 负载因子为0.75。

解决hash冲突(Hashmap如何解决散列碰撞)：
> 1、链式地址法。在冲突的位置拉一个链表，把冲突的元素放进去。(数组+链表结构)
> 2、扰动函数。(hash函数[哈希值的高16位^哈希值的低16位])。(从哈希值入手，尽可能保证哈希值不一样)
> 3、引入红黑树。(优化Hash表链表过长导致时间复杂度增加)
> 4、再Hash法(未使用)。利用多个hash函数，遇到冲突时就使用其他hash函数计算，直到不冲突。(缺点：计算时长增加)

##### 当两个对象的hashCode相等时会怎样
> 发生哈希冲突，若key值内容相同则替换旧的value，否则添加到链表后面，当链表长度超过阈值8，并且数组长度大于64就转为
> 红黑树存储。

##### hashmap扩容会有什么问题吗
> 链表可能会出现死循环。原因：多线程环境 + 链表头插法(jdk1.7为头插法，1.8后变成尾插法)
> <https://www.cnblogs.com/zhuoqingsen/p/8577646.html>

##### HashMap查找的时间复杂度是多少？
> 找表头元素是O(1)，因为数组的索引指定查找；链表时O(n)，红黑树时O(logN)

##### 为什么HashMap初始大小是2的次幂，对扩容有没有影响
> 能够满足位运算提高效率。(hash值很大，数组长度相对较小，需要取余才能作为数组下标，而位运算代替取余效率会很高)；     
> 打乱key的hash值[右移+异或]后在进行[&运算]能得到更平均的数组索引。(尽可能的将集合元素分配到数组的不同位置上，
> 减少哈希碰撞)。

> 扩容时扩大为原来长度的2倍，长度始终保持是2的n次幂。

##### HashMap的数据结构,如何保证快速查找。
> jdk1.7 数组+链表；jdk1.8 数组+链表+红黑树。当链表节点数量少时，查询时间较快；当链表节点多时，链表转红黑树。当红
> 黑树节点又变少时，红黑树转链表。

##### Hashmap底层为什么是线程不安全的
> 因为它的put方法无法保证原子性以及可见性。导致在多线程环境下扩容时会发生死循环(链表成环)，djk1.8会数据覆盖。

##### 解决hash冲突的时候，为什么用红黑树
> 当HashMap的key冲突过多时，会导致链表过长，此时链表的查询效率很差，引入红黑树优化查询效率，空间换时间。

##### 红黑树的效率高，为什么一开始不用红黑树存储
> 因为红黑树的节点比链表节点大(2倍)，占用空间更大，而且链表比较短的时候查询也足够快，没必要直接使用红黑树的结构。

##### 为什么HashMap阀值是8才转为红黑树
> 8其实是一个预估值。和hashcode碰撞次数的泊松分布有关，产生8次碰撞的几率为0.00000006，比千万分之一还小的概率。正
> 常情况下不会存储这么多数据，hashCode分布比较良好，数据分布也比较均匀，很少出现链表很长的情况。出于对时间和空间平衡
> 的选择结果。

##### 为什么HashMap退化为链表的阈值是6
> 如果退化阈值也设置为8，那么可能会出现链表和红黑树的不停相互转换，浪费资源；中间留下个差值7可以防止链表和树之间的
> 频繁转换。


##### ArrayList扩容机制？
> 初始容量为10，扩容因子为1，即当数组的长度小于最小需要的容量(当前元素容量+待添加的元素数量)就扩容。扩容后容量是原容量的1.5倍，计算方
> 式为`new = old + (old >> 1)`。

##### 为什么ArrayList扩容倍数是1.5
> 首先扩容容量不能太小，防止频繁扩容，数组频繁复制；第二，扩容容量不能太大，需要充分利用空间，避免浪费过多空间；还有就是
> 计算尽量高效，使用位运算的计算效率是比较高的。

##### ArrayList、LinkedList、Vector的区别
> ArrayList：使用可变数组实现，可以添加任何元素，包括null；  
> Vector：几乎与ArrayList一样，但是Vector是线程安全的；  
> LinkedList：双向链表实现，可以添加任何元素，包括null；

##### Map、Set、List、Queue、Stack 的特点与用法。
> Map：以key-value键值对结构存储元素；key唯一，value可以重复；元素可以无序(hashMap)，也可以有序(LinkedHashMap)   
> List：保存元素有序；允许重复元素，可以通过下标访问元素；   
> Set：保存元素元素唯一，可以排序(treeSet)；  
> Queue：先进先出；
> Stack：先进后出；

##### 链表的查找的时间复杂度是多少
> O(n)，因为链表始终需要按照顺序一个一个查找对比。

##### TreeMap、HashMap、LinkedHashMap的区别。
> HashMap：根据key的HashCode值存储数据，有很快的访问速度，取出的数据的顺序是随机的
> LinkedHashMap：内部有双向链表，存取元素时有序的(保存顺序与取出顺序一样)；
> TreeMap：基于红黑树实现，具有排序功能,默认是自然排序(升序)

##### 讲讲LinkedHashMap的数据结构，实现按顺序存取的原理。
> 继承HashMap，实现Map接口。内部维护代表链表头尾节点的两个对象，并且重写HashMap创建节点的方法，在调用父类put()添加
> 元素创建节点时，控制头尾结点，完成链表元素添加。当删除元素时也是先删除hash表上的元素，然后再通过重写方法移除节点。

##### ConcurrentHashMap
产生原因、区分jdk7跟jdk8的区别
> 因为HashMap是非线程安全的，在并发情况下存在很大的隐患(多线程扩容时，链表可能会出现死循环)；HashTable虽然是线程安
> 全的，但是因为它所有的get/put都添加了synchronized，导致性能非常差。于是ConcurrentHashMap便出现了。

jdk1.7版本：
> 底层数据结构是数组和链表。但是与HashMap不同的是引入了一个`Segment`的东西。Segment本身就像是一个HashMap，还继承
> ReentrantLock。HashMap的底层结构是个Entry数组，里面的元素是一个链表的表头，而ConcurrentHashMap的底层结构是
> Segment数组，每个Segment包含一个Entry数组，每个元素都是一个链表的表头。像个二级HashMap。
>
> 结构好处：使用分段锁技术，实现真正的并发。[多线程环境下，不同Segment之间读写互不影响；同一个Segment下的读取、一读
> 一写也能并发执行，写入并发时需要获取锁，否则阻塞。]坏处是查找过程要比普通的HashMap要长。
>
> 查找数据：需要进过2次查找，第一次定位到Segment，第二次定位到元素所在Segment内部数组元素，也就是对应链表的表头。
>
> 统计元素size：首先遍历所有的Segment，统计元素数量以及发生修改次数。当修改总数与上次统计一样时，说明没有修改，当前
> 统计的数量就是map内的总数量，统计结束；当不一样时，重新统计，统计计数器+1。当统计次数到一定数量(3次)时，对每个
> Segment加锁，再次统计，最后返回总数(加锁后无法再修改，所以前后修改次数是相同的)。     
> 原因：上来就直接锁住所有Segment，统计完再解锁。这样做会影响到Map的其他读写操作，不利于并行。

jdk1.8：
> 底层数据结构：为了提高并发性，放弃分段锁的方案；采用数组+链表+红黑树的数据结构，与HashMap一样。采用CAS+
> synchronized保证线程安全

##### HashMap和ConcurrentHashMap的区别
> 最大区别就是HashMap线程不安全、ConcurrentHashMap线程安全。

##### 二分搜索树的特性和原理
特性
> 每个节点的值都小于其右子树的所有节点的值；   
> 每个节点的值都大于其左子树的所有节点的值；     
> 每一棵子树也是二分搜索树；

##### 堆的实现，最大堆，最小堆，优先队列原理
> 堆的实现：使用优先队列(java自带的API PriorityQueue)、使用数组

优先队列
> 优先队列是一种特殊的队列，为元素赋予优先级，具有最高优先级的元素成为队列头部，一般分最大优先队列、最小优先队列。通过
> 下沉或上浮操作，保存队列头部始终最大或最小。

##### Comparable和Comparator的区别
> 所在包类不一样：comparable在`java.lang`包下，comparator在`java.util`包下   
> 实现重写方法不一样；实现comparable要重写compareTo(T o)方法；实现comparator要重写compare(T o1,T o2)方法；   
> Comparable是排序接口，实现它的类意味着自己本身具有比较功能，将自己与另外一个对象比较排序；Comparator是比较接口，
> 实现它的类能够将两个不同对象比较，自己本身无法比较排序。Comparable相当于内部比较器，而Comparator相当于外部比较器

##### LRU算法实现
> Least Recently Used的缩写，即最近最少使用法则。   
> 实现：使用双向链表+同步机制(比如Hashtable)或者LinkedHashMap。最近命中或新添加的放在头部，链表尾部的将会在容量
> 满时被移除。

##### ArrayMap和SparseArray
> SparseArray：使用2个数组(key数组+value数组)，key指定为int类型，不需要hash值，基于二分查找存取数据，提高查找效
> 率。它的删除也不是真正移除元素，而是设置一个删除标志。存储基本类型数据，避免数据的装箱拆箱，某些情况下性能更好。对
> 比HashMap，以时间换空间。它的出现是为了节省内存以及提高效率。不需要创建节点消耗内存。但也因为需要移动数组会消耗性
> 能，所以只适用数据量很小的情况。
>
> ArrayMap：类似ArrayMap，使用2个数组，mHashes和mArray。mHashes记录所有key的hashcode值；mArray记录所有
> key-value键值对，也都是基于二分查找存取数据。对比HashMap，同样不需要创建节点，节约内存，数据量小时查找效率更高，
> 不是和数据量大的环境。   
> ArrayMap解决hash冲突：向后追加。比如在位置i发生碰撞，则将i后的数据往后移，在i+1位置插入数据。mHash中相同的
> hashcode都是连接在一起的。