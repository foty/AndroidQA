### 内容包括：
* 基础语法：==、equals...
* string问题
* 面向对象(封装、继承、多态；接口)
* java静态
* 异常catch问题

知识点  [](../../../java/java基础.md)


##### 说说  ==、equals 和 hashcode
简单说说，无非是什么，有什么用，有什么区别。参考回答：
> 它们都是用来判断对象是否相等。
> 不同点：`双等号(==)`对于基本数据类型，只要它们的值相同，结果就是true，否则false。对于非基本数据类型对象，是判断
> 是否为同一个内存地址，同一个引用；`equals`是Object中的方法，并且Object中equals默认使用==来判断，判断内容是否相
> 同，也就是值比较，==是引用比较；  
> equals与hashcode也是比较2个对象内容是否相等，并且都是Object中的方法。如果2个对象相等，hashcode一定相等，equals
> 也是返回true；如果只有equals相等，2个对象也是相等，它们的hashCode()也一定相等；如果只有hashcode相等，2个对象不
> 一定相等，equal也不一定相等。equal对应是准确性，hashcode对应是效率。

##### 为什么有了equals(hashcode)还要hashcode(equals)。
> 因为重写equal比较全面、复杂，效率就变低，而利用hashCode进行对比，只要生成一个hash值进行比较就可以，效率比较高。
>
> 因为hashCode并不完全可靠，有时候不同的对象他们生成的hashcode也会一样。(java中的hash函数返回的是int类型，对于
> hashcode的计算也是有限的，数据量大就有可能出现相同的hash值)

##### equals 和 hashcode如何协调比较。
> 当需要对比的时候，首先用hashCode去对比，如果hashCode不一样，则表示这两个对象肯定不相等，就不必再用equal去比较；
> 如果hashCode()相同，再对比他们的equal()。如果equal()也相同，则表示这两个对象是相同的。这样既能提高效率也能
> 保证准确性。

##### equals、hashcode为什么必须重写,只重写一个会怎样。
只重写一个无法保证准确性，无法满足所有需求，还会引发其他错误。
> 只重写equal，那么2个对象比较的就是hashcode，这个值是由内存地址转化而来，不同对象一定不同。这会导致创建的2个对象所
> 有属性都相同，但是因为hashcode没有重写，程序识别为2个不同的对象。即是equals相等了，hashcode也不等，违反hashcode
> 规则。  
> 只重写hashcode，那么比较的其实是对象的地址值(equals默认==实现)，不同对象也一定不同，甚至可以说2个对象永远不会相
> 等；

##### HashMap和HashSet为什么必须同时重写hashcode和equals。
> 一是hashcode和equals只重写其中一个都无法保证HashMap与HashSet内元素的准确性，就是无法判断2个对象是否相等；   
> 二会导致hash容器无法正常工作。(hash表是以key-value保存数据，key就是根据对象hashcode计算而来：
> 计算key下标的方式：(n - 1) & hash，n是数组长度。只重写equals会导致hashcode出现相同，导致无法保证key的唯一性)；
> 只重写hashcode会导致2个不同对象会被挂载到同一个key上，后挂载的会替换前挂载的，导致使用key获取的不是同一个对象。)

##### HashCode的作用
> 对象区别于其他对象的标识,hashcode是当前对象的地址值计算转化来的。

##### Switch能否用string做参数
> Java 1.7之前只能支持byte、short、int、char或其封装类及enum类型，1.7及以上才支持string，boolean类型也是不支持

##### java基本数据类型有哪些，int，long占几个字节
> 4类8种。
> 整数类(byte[1个字节，-128~127]、short[2个字节，-32768~32767]、int[4个字节，-2的31次方~2的31次方-1，约21亿]、
> long[8个字节])；   
> 浮点类(float[4个字节]、double[8个字节])、   
> 字符类(char[2个字节])、  
> 布尔类(boolean[占1位]);除此外都是引用数剧类型。

##### Java面向对象的三个特征与含义。
> 封装：把客观事物封装成类或对象，隐藏对象的属性和实现细节，对外提供接口访问；   
> 继承：让某个类型的对象获得另一个类型的对象的属性和方法。继承导致类之间有分等级层次，子类可以继承父类的特征和行为，使
> 得子类具有父类相同的属性和行为；   
> 多态：同一个行为，不同的子类对象具有不同的表现形式。只有在运行的时候才知道引用指向的是哪个类的实例对象，以及引用调
> 用的方法指向的是哪个类中实现的方法。比如`重载`跟`重写(覆盖)`，父类引用指向子类实例等等。

##### java有什么特性，继承有什么用处，多态有什么用处。
> 封装：对内部数据提供了不同级别的保护，代码重用；
> 继承：扩展已存在的类或对象，代码重用；
> 多态：增加类或对象使用的灵活性和扩展性；

##### Java中提供了抽象类还有接口，开发中如何去选择呢？
> 根据具体情况和需求来选择。接口可以多实现，抽象类继承是单继承。抽象继承注重重用的扩展，更像是一种模板，有公共部分也有自定
> 义部分，耦合度高；接口注重共享行为规范，不关心具体实现，更像一种附加功能形式，耦合度低。

##### java为什么能做到多态
> 只有在运行的时候才知道引用指向的是哪个类的实例对象，以及引用调用的方法指向的是哪个类中实现的方法(运行时类型判定)。
> 因为    
> 1、类之间的继承关系。  
> 2、方法的重载跟重写。   
如果子类改写了父类的方法，那么子类和父类的同名方法共享一个方法表项，都被认作是父类的方法。在调用子类方法时，通过解析子
类实例方法获取对应方法表中的偏移量，通过偏移量找到实际的方法。

##### Override和Overload的含义去区别。(重载和重写)
> Override：重写/覆盖。方法名、参数、返回值与父类完全相同。存在与父类子类之间；   
> overload：重载。方法参数的类型、个数、顺序至少有一个不相同。存在同个类的方法与方法之间；

##### String s = new String("xx")创建了几个对象
> 1个或者2个。如果常量池存在"xx",就是创建了1个，如果常量池不存在"xx",就是2个(引用对象s不算)。

##### new String("a") + new String("b")有几个对象
> 6个。分别是 new StringBuilder(拼接的默认使用StringBuilder拼接)，常量池a，堆内存a(new String(a))，常量池b，
> 堆内存b，堆内存ab。[注意，常量池内没有"ab"]

##### String的intern()会发生什么
> jdk1.6，如果常量池存在该对象，不会再次放入池，返回`常量池对象地址`；如果不存在，复制一份`对象`放入常量池。返
> 回`常量池对象`。(相当于有2个对象，2个对象不是同一个)。   
> jdk1.7及以上，如果常量池存在该对象，不会再次放入池，返回`常量池对象地址`；如果不存在，复制`对象引用`放入常量池，返
> 回`常量池的引用`。(常量池的是原对象的引用地址，都是同一个对象)

##### String是最基本的数据类型吗
> 不是。

##### 是否可以继承String类
> 不能，String是final修饰的，实现细节不允许改变。

##### 为什么final不能被继承
> 在java中，final关键字是“这是无法改变的”或者“终态的”含义。规定无法被它修饰的类无法继承，可能是出于设计或者效率。

##### String、StringBuffer与StringBuilder的区别。
都可以用来表示字符串。
> String是固定长度字符串，即是有拼接操作也是返回创建新的字符串对象；而StringBuffer与StringBuilder是可变字符串，
> 可以在原对象基础上拼接，对象不会改变(原因是它们内部使用char数组拼接处理)；所以String做拼接效率很低。String适用于
> 少量的字符串操作，StringBuffer与StringBuilder适用于大量字符串操作。    
> StringBuilder是线程不安全的，单线程环境表现突出。StringBuffer是线程安全的，多线程环境下表现突出。(内部的char数
> 组基础容量是16，每次扩容为增加原来一倍+2)

##### &和&&的区别？
> & 属于位运算，按位与，&&属于逻辑运算，逻辑与。   
> &&有短路功能，即第一个表达式为false时，整个结果就是false，不再判断第二个表达式；&没有短路功能

##### 值传递与引用传递？java是引用传递还是值传递
值传递和引用传递的区别并不是传递的内容，而是实参到底有没有被复制一份给形参。
> 值传递：复制一份变量传递给其他变量，在方法中修改并不会改变原始变量的值；引用传递：直接传递对象的地址，修改会改变对象
> 本身的值。    
> java是值传递，没有引用传递。对于基本数据类型，是传递对象量值的副本；对于引用类型，是该对象在内存中的地址值的副本。

##### int和Integer区别
> Integer是int的包装类；int是基本数据类型;   
> Integer变量必须实例化后才可以使用，而int变量则不需要;  
> Integer的默认值是null，而int的默认值为0.

##### char类型变量中能不能存贮一个中文汉字
> 可以。char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含汉字。如果某个汉字没有被包含在unicode编码
> 字符集中，那么这个char型变量就不能存储这个汉字。unicode编码占用两个字节；char类型的变量也是占用两个字节。

##### java中静态方法，能不能被子类重写？编译会报错么
> 不能重写。静态方法只与类有关系，跟实例对象没有关系。重写是为了多态，静态方法在加载时就绑定了类，不存在父类引用指向子
> 类实例，也就不存在多态。但是子类可以声明与父类相同参数，同名的静态方法，但是这个类是绑定子类的，不能加重写注解。

##### 在一个静态方法内调用一个非静态成员为什么是非法的？
> 静态方法是跟随类的，随类的加载而加载；而非静态方法属性是属于对象的，对象是在类加载完后创建生成的。对象没有生成，非静
> 态成员当然也不存在。只依赖于类而不依赖于对象的静态方法自然不能调用一个不存在的方法，也不知道哪个对象，哪个成员变量。

##### 静态内部类是什么？静态类与非静态类的区别。
> 静态内部类不持有外部类的引用，内部类持有外部类的引用。(这也是第二点内部类能访问外部类的原因)  
> 静态内部类只能访问外部类的静态方法和静态属性，内部类能访问外部类的所有方法或者属性；  
> 静态内部类的方法可以是静态的方法也可以是非静态的方法，普通内部类不能声明static的方法和变量；

##### 匿名内部类的特点
> 匿名内部类可以访问外部内的所有成员，外部类不能访问内部类的属性、方法   
> 匿名内部类不能访问外部类未加final修饰的变量(jdk1.8即使没有用final修饰也可以访问)   
> 匿名内部类中不能定义静态属性、方法   
> 内部类的隐藏属性this、super都是指向内部类自己。

##### 匿名内部类能不能访问外部类的私有方法(属性)？为什么
> 可以。内部类总有一个隐式引用指向外部类，在编译过程中，编译器会为外部类的私有属性生成静态方法。

##### 匿名内部类编译后也是独立的外部类，它为何能访问外部类的私有方法？如果能访问，怎么做到的？
> 内部类总有一个隐式引用指向外部类，在编译过程中，编译器会为外部类的私有属性生成相应的静态方法。

##### try catch finally，try里有return，finally还执行么
> 会执行。但是finally无法改变返回值。因为在执行的过程中, 如果try执行到return,会先将结果保存在一个临时变量中,等
> 到finally执行完毕之后再将保存的值取出返回。

##### Java异常机制中，异常Exception与错误Error区别
> Exception是可预料的异常情况，可以捕捉处理的；
> Error是java程序运行中不可预料的异常情况，无法处理(Exception又分为检查性异常和非检查性异常)；

##### foreach与正常for循环效率对比。
> foreach效率更高。foreach只能用于遍历，不能更改循环目标，遍历速度快，执行效率高。for循环可以用于任何形式的重复行
> 为，在循环体中可以进行任何操作，所以遍历速度慢，执行效率低。

##### 装箱和拆箱的原理
> 装箱：自动将基本数据类型转换为包装器类型，调用`valueOf()`完成装箱；    
> 拆箱：自动将包装器类型转换为基本数据类型，调用了`***Value()`完成拆箱；   
