
###
* jvm内存模型
* jvm的加载器，类加载
* Android中的类加载器
* GC

知识点： [](../../../java/jvm.md)


##### 什么是JVM
> Java Virtual Machine，即java虚拟机，用来处理java程序的核心。

##### 类加载机制的几个阶段 (类加载过程)
> 加载、链接(验证、准备、解析)、初始化、使用、卸载

##### Java对象如何创建的，对象创建过程 (描述new一个对象的流程)
> 首先通过`new`关键字声明一个引用符号；   
> jvm对引用符号判断是否加载类该，如果没加载就加载类；    
> 为对象分配内存空间；(指针碰撞法、空闲列表法)；   
> 设置默认值(零值)；  
> 设置对象头(信息标记，比如是新生代还是老年代、锁标志等等)；   
> 执行构造方法；

https://blog.csdn.net/qq_36986015/article/details/113740499

##### 对象加载的过程，属性先加载还是方法先加载
> 静态的属性跟方法优先与普通属性跟方法。同是静态的或者普通，按代码先后顺序加载

##### 对象实例化时的顺序
> 1、加载父类的静态成员变量和静态代码块，按代码先后顺序进行   
2、加载子类的静态成员变量和静态代码块，按代码先后顺序进行   
3、加载父类成员变量和方法，按代码先后顺序进行   
4、加载父类的构造函数   
5、加载子类成员变量和方法，按代码先后顺序进行   
6、加载子类的构造函数

总结就是：静态优先非静态，父类优先子类，构造方法最后，同级别按代码先后顺序。

##### java中的类什么时候会被加载？类加载的过程具体生命周期是怎样的？
java程序启动时，并不是一次性加载所有.class文件。而是在程序运行中动态加载相应的类到内存中。当一下2点触发时，.class文件会被加载器主动加载：
> 1、；用类的静态成员时(静态属性,静态方法)。   
> 生命周期：加载、验证、准备、解析、初始化、使用、卸载。


##### 说说JVM运行时数据区 (就是内存分区)
> 运行时数据区，是java虚拟机定义的在程序执行期间使用的各种运行时的数据区。一般分成俩种，一种是线程共享的，一种的线程
> 私有的。其中虚拟机栈、本地方法栈、程序计数器是线程私有的，方法区、堆是线程共享的。

##### 说说JVM的内存分区，各个分区的作用
有2类5种。2类是线程共享和线程私有。虚拟机栈、本地方法栈、程序计数器属于线程私有的，方法区、堆属于线程共享。
> 虚拟机栈：也称栈内存，堆栈。每个java方法都会创建一个栈帧。用于存储局部变量表、操作数栈、动态链接和方法出口等信息(8大基本类型+局部对象引用+实例方法)。   
> 本地方法栈：和虚拟机栈类似，只不过是Native方法服务，不是java方法。(native方法)    
> 程序计数器：当前线程所执行的字节码的行号指示器，记录当前线程执行的位置。唯一不会产生OOM的区域。(正在执行的jvm指令)    
> 方法区：主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。比较少产生GC。(常量池、静态、类信息等)    
> 堆：所有线程所共享的一块内存，存放实例对象(通过new创建)，经常发生GC，又称GC堆。 (实例对象)

##### Jvm的内存结构中，方法区有什么东西
> 虚拟机加载的类的信息、成员变量、方法、常量、静态变量和即时编译器编译后的代码等数据

##### java对象会不会分配到栈中？
> 会，局部变量分配在虚拟机栈。new 初始化的对象都分配到堆中。
> 如果对象经过逃逸分析确认为不逃逸对象，并且确定该对象不会被外部访问，那么jvm将不会创建对象放到堆中，而是将对象分解
> 成被这个方法使用的其他变量替换，这就是标量替换。

##### 什么是对象逃逸分析？
> 对象逃逸分析就是分析对象的动态作用域。当一个对象在一个方法中被定义之后，它很有可能被外部方法所引用，例如作为调用参数传递到
> 其他地方中。

##### 程序计数器为什么设计成私有
> 在多线程情况下，程序计数器用来记录自己线程的执行位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿。

##### 虚拟机栈和本地方法栈为什么设计成私有
> 虚拟机栈保存java方法的局部变量表、操作数栈等信息，为了保证线程中的局部变量不被其他线程访问到

##### 虚拟机如何解决内存分配并发问题
> jvm内存分配并发产生原因：计算机(cpu)的运算速度与它的存储和通信子系统的速度差距太大。   
> 为对象分配内存的基本方法：`指针碰撞法`、`空闲列表法`  
> 解决并发问题的方法：`CAS+失败重试`、`TLAB`--本地线程分配缓冲(Thread Local Allocation Buffer)

TLAB：
> 本地线程分配缓冲(Thread Local Allocation Buffer)，它是在Java堆中划分出来的针对每个线程的内存区域，专门在该区
> 域为该线程创建的对象分配内存。     
> 它的主要目的是在多线程并发环境下需要进行内存分配的时候，减少线程之间对于内存分配区域的竞争，加速内存分配的速度。   
> 原理：启用了TLAB之后(-XX:+UseTLAB, 默认开启)，JVM会针对每一个线程在Java堆中预留一个内存区域，在预留这个动作发生
> 的时候，需要进行加锁或者采用CAS等操作进行保护，避免多个线程预留同一个区域。一旦某个区域确定划分给某个线程，之后该线
> 程需要分配内存的时候，会优先在这片区域中申请。

##### 对象内存分配策略
> 堆分年轻代、老年代。年轻代分Eden区和Survivor区。对于新对象：优先在年轻代的Eden区，大对象直接进入老年代；经过GC后，
> 对象会进入到Survivor区；在年轻代长期存活的对象(15次GC)将进入老年代。


##### 类加载器,双亲委派及其优势
> 类加载器负责读取java字节码文件，将class文件加载到内存。类加载器分：  
> 1、启动类加载器(Bootstrap ClassLoader)：c++实现，负责加载java的核心类。   
> 2、扩展类加载器(Extension ClassLoader)：负责加载ava扩展库；  
> 3、应用程序类加载器(Application ClassLoader)：负责加载用户类路径(class.path)上的指定类库  
> 4、自定义类加载器()：自定义类加载器以ClassLoader为基类，重写其中的findClass，从指定的位置读取字节码文件。

双亲委派及其优势
> 双亲委派机制就是：收到类加载请求的时候，不会先自己去加载类，而是把请求委托给父类加载器，依次向上。最后所有的类加载请
> 求都会被传递到最顶层的启动类加载器中，只有当父类加载器中无法加载到所需的类，子类加载器才会自己去加载类。   
> 好处：避免类的重复加载、保护程序安全，防止核心API被篡改。


##### Android中的PathClassLoader与DexClassLoader有什么区别
> 都能加载外部环境的jar/apk文件。8.0(26)以前，DexClassLoader多一个optimizedDirectory参数，可以设置这个目录，
> 而PathClassLoader只能使用系统默认位置。8.0(26)之后，这个参数失效，二者没有什么区别。

##### Android中加载类的方法有哪些？有什么区别？
> 3种。BootClassLoader、PathClassLoader与DexClassLoader。
> 区别：BootClassLoader用于加载Framework底层.class文件，PathClassLoader是加载除了底层之外的类，例如第三方插件，或
> 者开发者编写，或者指定的dex文件，jar等等；DexClassLoader也是加载指定dex，或者jar、apk、zip

##### 破坏双亲委派机制的方式
> 自定义类加载器，重写loadclss()方法。
> 使用线程上下文类(ServiceLoader：使父加载器可以加载子加载器的类)

##### 什么是双亲委托机制，为什么需要双亲委托机制？
> 双亲委派机制就是：收到类加载请求的时候，不会先自己去加载类，而是把请求委托给父类加载器，依次向上。最后所有的类加载请
> 求都会被传递到最顶层的启动类加载器中，只有当父类加载器中无法加载到所需的类，子类加载器才会自己去加载类。   
> 使用原因：避免类的重复加载、保护程序安全，防止核心API被篡改。

##### ClassNotFound的有可能的原因是什么？
> 类路径不对；类没有被加载(出现异常或者没有这个类)。

##### odex了解吗？解释型和编译型有什么区别？
> odex全称：OptimizedDEX，表示经过优化的dex文件。就是把.dex 文件从Zip压缩包中的提取。  
> 编译型语言：利用编译器将源码一次性全部转换成二进制指令，生成可执行程序，如C/C++等。  
> 解释型语言：一边执行，一边使用解释器转换，如JavaScript，php。


##### GC原理，有哪几种GC方式
> GC就是将不需要的对象占用的内存回收。原理就是标记为垃圾，然后通过回收算法回收。  
> 标记算法有：`引用计数法`、`根搜索法`(可达性算法)；   
> 回收算法有：`标记-清除算法`、`复制算法`、`标记-压缩(整理)算法`、`分代收集算法`。

##### 讲讲你对垃圾回收机制的了解(GC流程是怎样的?)<同上问题>
GC机制能帮我们把不需要的对象占用的内存回收，保证程序高效的运行。
> GC包括标记垃圾和回收垃圾2个步骤。标记使用的算法有`引用计数法`和`根搜索法`(可达性算法)。回收算法
> 有`标记-清除算法`、`复制算法`、`标记-压缩(整理)算法`、`分代收集算法`。

引用计数法
> 每个对象上都有一个引用计数。对象每被引用一次，引用计数器就+1，对象引用被释放，引用计数器-1，直到对象的引用计数为0，对象就标
> 识可以回收。缺陷就是对于循环引用的情况下，循环引用的对象就不会被回收。比如A,B只有相互引用，它们也不会回收。

Root搜索算法(可达性算法)
> 目前大部分JVM所使用的标记算法。以root对象集合中的root对象出发，进行自上往下的搜索，与根对象直接连接或间接连接的对象都可以被搜索。当
> JVM无法到达某个对象时，它会被标记为可清除对象。

标记-清除算法：
> 通过标记算法，标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象

复制算法
> 首先将可用内存分为大小相等的两块，每次只使用其中的一块；当这块内存用完，将还存活的对象连续复制到另一块上面，然后把使
> 用过的那块内存空间一次清理掉。

标记-压缩(整理)算法
> 使用标记算法，标记出所有需要回收的对象；让所有的存活的对象都向一边移动，然后直接清除掉边界以外的内存。

分代收集算法
> 将堆内存划分为`年轻代`和`老年代`不同年代根据自身特性采用不同的垃圾收集算法。年轻代:老年代空间 = 1:2    
> 新生代：每次GC时都有大量的对象死亡，只有少量对象存活。考虑到复制成本低，适合采用`复制算法`；    
> 老年代：因为对象存活率高，没有额外的内存空间对它进行担保。因而适合采用`标记-清理算法`或`标记-整理算法`进行回收；

年轻代
> 年轻代的GC叫Minor GC。因为使用复制算法，优化后分为较大的`Eden`空间和2块较小的`Survivor`空间。每次使用Eden和一
> 块Survivor空间。Eden与2块Survivor空间比为 8:1:1。      
> 当Eden满时触发GC，把Eden存活的对象放在Survivor空间。当Eden区又满了时，把Eden区和Survivor区的存活对象放到另外
> 一块Survivor空间，循环使用。当Survivor区也快慢了，就会转移部分对象到老年区。

老年代
> 使用标记-清理或标记-整理算法，存放生命周期较长的对象。当年轻代的对象经过多次GC(15次)仍然存活或者是大对象会转移到老年代。  
> Full GC是清理整个堆空间，包括年轻代和永久代。触发Full GC的条件有：
> 1、老年代空间不足；   
> 2、调用System.gc()；   
> 3、分配很大的对象；(因为需要很大的连续空间，但又没法找到足够大的连续空间)

##### 老年代有什么算法？
> 老年代因为对象存活率高，没有额外的内存空间对它进行担保。适合用`标记-清理算法`或`标记-整理算法`进行回收。

##### Java中对象如何晋升到老年代？
> 年轻代的对象经过多次GC(15次)仍然存活，或者大对象时，就转移到老年代。

##### 拉圾回收的GCRoot是什么
> 是判断是否需要回收的标记算法中根搜索算法中的一个名词，参考了图论的观点，把所有的引用当成一张图，图的第一个节点(对象)就是
> GC_Root。根据每个对象的引用是否能到达GC-Root，如果不能就表示该对象是垃圾。能当成GC-Root的对象有：
> -虚拟机栈中的对象引用；   
> -方法区中的类静态属性的对象引用；   
> -运行时常量池中的对象引用；   
> -本地方法栈的对象引用；   
> -被启动类加载器加载的类和创建的对象

##### Java中有几种引用关系，它们的区别是什么？
> 强引用：永远不会回收；
> 软引用：系统内存不够了才会回收；
> 弱引用：优先级倒数第二低，被标记弱引用，下次GC就会被回收；
> 虚引用：优先级最低，随时可能会被回收

##### StackOverFlow与OOM的区别？分别发生在什么时候，JVM栈中存储的是什么，堆存储的是什么？
当线程调用一个方法时，jvm压入一个新的栈帧到这个线程的栈中，只要这个方法还没返回，这个栈帧就存在。
> StackOverFlow是方法栈帧调用太深，导致线程内栈帧数量大于最大值而溢出，就会抛出这个异常。例如无限递归某个方法；
> OOM是JVM中堆区为对象申请的内存空间不够用时产生。；   
> 栈中主要是用于存放程序运行过程中需要使用的局部变量，操作数栈和临时数据等；堆中主要存储程序运行中创建的实例对象。

##### 对象的访问定位有哪几种
> 直接指针访问、句柄访问(如果是句柄访问堆会划分一块内存作为句柄池，引用中存储的就是对象的句柄地址)。HotSpot使用是直接指针
> 访问对象。

##### 例如启动20s，如何知道gc了多少次，花费了多少时间。可以针对性做哪些优化
> 查看次数：jvmti工具、leakcanary做法