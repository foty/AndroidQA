
###

* 线程    [](../../../java/线程.md)
* 多线程   [](../../../java/线程池.md)
* 线程池：原理、epoll、      [](../../../java/并发(锁).md)
* 锁：原子性、可见性、有序性
* 同步：synchronized、volatile、CAS、AQS


##### 实现多线程的两种方法。
> 继承Thread类或实现Runnable接口。

##### 创建线程的几种方式
> 继承Thread类、实现Runnable接口、创建Callable接口的实现类、使用线程池。

##### 线程的几种状态
> 新建、就绪、运行、死亡、堵塞。

##### 怎么中止一个线程，Thread.Interrupt一定有效吗
> 1、设置flag，让run()提前结束。   
> 2、使用stop()方法强行终止线程。   
> 3、使用interrupt()方法.

interrupt()一定有效吗
> 通过调用interrupt()方法是将isInterrupt标志位变成true，当run方法知道到该标志位时就会抛出异常达到终止线程的目的。理
> 论上是有效的。

##### wait()和sleep()的区别
> sleep不释放锁，wait释放锁;   
> sleep是Thread的方法，wait是Object的方法;

##### interrupt()、interrupted()、isInterrupted() 区别
> interrupt()：改变中断状态，它不会中断一个正在运行的线程。返回值时void。   
> interrupted()：测试是否中断，返回当前线程的中断标志位(boolean值)，并设置中断标志位为false；   
> isInterrupted()：测试是否中断，返回线程对象的中断标志位。

##### start()、run()的区别
> start()是启动一个线程，run()只是调用一个方法。
> run()可以重复调用，start()不可以。   
> start()实现了多线程，run()没有实现多线程。

##### 多线程存在哪些问题
> [原子性问题]：A给B转账100，对应的操作就是A-100，B+100。如果没有原子性，只是单方面加或减,必然会产生问题。     
> [可见性问题]：多线程访问同一个变量时，一方面对变量修改，其他线程应该立即看到修改，如果不及时也必然会产生问题。   
> [有序性问题]：主要是jvm为了提高效率，会改变程序语句的执行顺序。比如双重检查创建单例对象。程序顺序是先分配内存、然后初
> 始化、最后将内存地址给单例对象。然而经过jvm的优化后，顺序变成了先内存地址给单例再初始化。造成的结果就是单例对象没有
> 初始化，引发空指针异常。    
> [死锁]。

##### 并发和并行区别
> 并行： 指两个或多个事件在同一时刻发生；   
> 并发： 指在同一时刻，只能有一个事件执行，但多个进程原因被快速轮换执行，使得宏观上具有多个事件同时执行的效果。   
> 举个例子：并发是一个人同时吃三个馒头，而并行是三个人同时吃三个馒头。

##### 如何让两个线程循环交替打印
> 常规方法，[while阻塞+flag]。声明一个flag，2条线程，一条线程flag为true时打印，一条为false时打印。中间使用while阻
> 塞，每次打印完将flag设置为对方的flag打印状态。

例子看[Bb.testNormal()]

##### 三个线程依次打印，有哪些方式
> [flag+while阻塞+ReentrantLock+Condition]。flag控制打印线程顺序，ReentrantLock控制线程加锁与释放锁，while，
> Condition控制阻塞与唤醒。每当一条线程打印完，唤醒下一条需要打印的线程并且释放锁。

例子看[Bb.print3()]

##### 为什么会有线程安全？如何保证线程安全
> 因为系统调度线程具有随机性，会导致数据操作的原子性、可见性、有序性无法保证而产生bug，这时线程就是不是安全的。保证
> 原子性、可见性、有序性的就是线程安全。

如何保证线程安全
> 使用synchronized、Lock锁(如[ReentrantLock])保证线程同步；使用volatile保证可见性，禁止指令重排(有序性)


##### 线程池中线程复用原理
> 线程池将线程和任务进行解耦，线程是线程，任务是任务，摆脱了之前通过创建线程时的一个线程必须对应一个任务，任务执行完线程就
> 销毁的限制。在线程池中，对线程和任务进行了封装，任务都加入到一个任务队列中，每个线程去执行任务队列中的任务。线程不停地
> 从任务队列中获取可执行任务。如果有则直接执行，否则就阻塞。

##### 为什么线程池使用阻塞队列（BlockingQueue）
> 阻塞队列可以保证任务队列中没有任务时，阻塞获取任务的线程，使该线程进入wait状态，释放cpu资源。当队列中有任务时才唤醒
> 对应线程从队列中取出消息进行执行。 使得线程不至于一直占用cpu资源。

##### 关闭线程池方式
> shutdown()：线程池即使不执行任务也会占用一些资源.   
shutdownNow()：将线程池设置为 STOP，然后尝试停止所有线程，并返回等待执行任务的列表。  
共同点：都是通过遍历线程池中的线程，逐个调用 Thread.interrup()来中断线程，所以一些无法响应中断的任务可能永远无法停止。  
不同点：shutdown() 只结束未执行的任务；shutdownNow() 结束全部。

##### 线程池了解多少？拒绝策略有几种,为什么有newSingleThread
> 4种拒绝策略。简述为：拒绝无处理、拒绝并抛异常、直接执行、抛弃最旧的任务执行新任务。

##### 线程池核心参数
> `corePoolSize`核心线程数量，`maxPoolSize`最大线程数量，`keepAliveTime`线程存活时间，`unit`存活时间单位，
> `workQueue`工作队列，`threadFactory`执行器创建新线程时使用的工厂，`handler`拒绝策略。

##### 为什么用线程池
> 节约资源。重用线程，减少新建-销毁线程的开销，还能有效控制线程并发数量，避免线程间抢占系统资源而导致阻塞；   
> 能够统一管理；

为什么有newSingleThread(newSingleThreadExecutor)
> 这是一个单一线程池。corePoolSize为1，maximumPoolSize为1，keepAliveTime为0，阻塞队列使用的是
> LinkedBlockingQueue。该线程池的特点是保证了所有任务的执行顺序按照提交顺序来执行。

##### ThreadLocal的设计理念与作用。
> 理念：在多线程并发执行过程中，为了保证多个线程对变量的安全访问。   
> 作用：使变量在每个线程中都有独立值，不会出现一个线程读取变量时被另一个线程修改的现象。

##### 如何配置线程池的？核心线程数一般是怎么配置的
> 考虑CPU核心数，再看是CPU密级型任务还是IO密级型任务。如果是CUP密集型，核心线程数 = CPU核数即可。也可以设置为CPU核
> 数+1，达到最大利用率。如果是IO密集型任务，则跟CPU计算速度和IO读写速度相关，可以分别计算2者的一个比值关系乘以cpu核数。

##### 假如只有一个cpu，单核，多线程还有用吗?
> 有用。多线程允许同时执行多个任务，可以通过时间分片切换不同线程执行; 比如大量IO操作时，使用多线程可以提高效率，在等待某个
> 线程结果时，CPU可以切换到其他线程处理。

##### 谈谈线程死锁，如何有效的避免线程死锁？
> 死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象。产生死锁的必要条件有：
> 1、互斥条件(某个资源被一条线程使用时，其他线程无法使用)；   
> 2、不可剥夺(线程获取到的资源在自己使用完之前无法被其他线程占用，只能自己使用完后自己释放)；   
> 3、请求并且持有条件(一个线程持有了一个资源，又去请求新资源，但新资源被已被占用，自己陷入阻塞又无法释放持有资源)；   
> 4、环路等待条件(发生死锁时，必然存在一个等待资源线程--占用资源线程的环形链)

避免死锁
> 破坏死锁的4个必要条件即可避免死锁。第一、第二非程序本身能够控制，所以只能破坏第三、第四个条件之一。比如：  
> 保证资源使用的有序性能破坏请求并持有条件，设置等待时间、定时锁可以避免一直阻塞无法释放破坏环路等待条件。

##### 如何实现多线程中的同步
> synchronized同步方法、同步代码块、使用Volatile、使用重入锁(ReentrantLock)

##### 何为阻塞队列
> 阻塞队列是一个支持两个附加操作的队列。这两个附加操作是：在队列为空时，获取元素的线程会等待队列变为非空;当队列满时，
> 存储元素的线程会等待队列可用。

##### 锁的分类，锁的几种状态
> 可重入锁：线程获取到锁后可以重复获取锁并且不会导致死锁。在java中有：ReentrantLock、synchronized。
> 公平锁：多个线程之间通过申请顺序来获得锁权限
> 非公平锁：非公平锁则是指线程之间获得锁的顺序不是按照申请顺序
> 互斥锁：线程获取到锁后，其他线程再次获取锁会失败，然后释放cpu，进入阻塞状态(与自旋锁相反)
> 自旋锁：指尝试获取锁的线程后不会立即阻塞，而是通过循环的方式去尝试获取锁。

锁有四种状态，随着锁的竞争，锁的状态只有升级，没有降级。偏向锁->轻量级锁->重量级锁。
> 无锁    
> 偏向锁：特点是加锁和解锁不需要额外的消耗。但是如果有多个线程竞争，会带来额外的锁撤销消耗。适用于单线程环境。    
> 轻量级锁：特点竞争的线程不会阻塞，提高响应速度。但始终无法竞争到的线程会进入自旋消耗cpu。适用追求响应时间，执行速度
快的环境。     
> 重量级锁：特点是线程竞争不会自旋，不会消耗cpu。但线程会进入阻塞状态，响应慢。

##### 如何避免死锁
> 破坏产生死锁的4个必要条件。`互斥`，`不可剥夺`，`请求并持有`，`环路等待`。实际当中，第一、第二点无法或很难实现，所以
> 可以针对第3、4条件处理。比如保证请求资源的有序性，可以避免请求并持有条件；设置锁定时间，定时释放可以避免环路等待。


##### 平常有用到什么锁，synchronized底层原理是什么
> 是对jvm层面的monitor对象加锁解锁实现同步。方法级别的同步是根据方法表中的同步标志判断是否事同步方法。如果是则会先去获
> 取monitor对象，执行完方法释放monitor对象；代码级别的同步是根据monitor-enter和monitor-exit指令完成。执行
> monitor-enter获取monitor对象，执行monitor-exit，释放monitor对象。

##### 说一下synchronized的作用。
> 对于单一JVM来说，synchronized可以保证在并发情况下，同一时刻只有一个线程执行某个方法或某段代码，它可用于修饰方法或
> 代码块，实现对同步代码的并发安全控制。

##### synchronized可用于修饰方法和代码块，他们有什么区别呢？
> 修饰方法在底层实现上是在方法访问标识中设置ACC_SYNCHRONIZED标示符；修饰代码块在底层实现上会使用monitor-enter和
> monitor-exit指令。

##### synchronized修饰方法方式的底层实现原理？
> 修饰方法通过编译后，会在方法表结构中设置ACC_SYNCHRONIZED访问标识。每个对象都与一个monitor相关联，当且仅当
> monitor被线程持有时，monitor会处于锁定状态，也就是加锁。当方法执行时，线程将先尝试获取对象相关联的monitor所有权，
> 然后再执行方法，最后在方法完成(无论是正常执行还是非正常执行)时释放monitor所有权。在方法执行期间，线程持有了monitor
> 所有权，其它任何线程都无法再获得同一个对象相关联的monitor所有权。

##### 说说对象头
> 对象头由以下几部分组成:
* 第一部分存储对象自身的`运行时数据(Mark Word)`：哈希码、 GC分代年龄、锁标识状态、线程持有的锁、偏向线程
  ID(一般占 32/64bit)；
* 第2部分是`指针类型`，指向对象的类元数据类型（即对象代表哪个类）；
* 第3部分是`数组长度`，但是只在数组对象才会有；

##### 一个对象的锁状态存在哪里
> 在Java对象的对象头Mark Word(运行时数据)中。

##### synchronized修饰代码块方式的底层实现原理？
总结就是monitor-enter指令和monitor-exit指令以及monitor计数器实现。

> 添加synchronized修饰代码块，编译后会在逻辑代码前添加monitor-enter指令，在逻辑代码尾添加monitor-exit指令。当方法
> 执行时，当前线程执行monitor-enter指令获取对象相关联的monitor所有权。如果此时这个monitor的计数器是0，那么当前线程
> 持有该monitor，同时monitor计数器设置为1；如果当前线程已经持有了对象相关联的monitor所有权，只是想重新获取，那么继
> 续持有该monitor，同时monitor计数器加1；如果有其它线程已经持有了对象相关联的monitor所有权，当前线程会进入阻塞，直
> 到monitor计数器为0，再次尝试获取所有权。方法正常执行或发生异常时，会执行monitor-exit指令，释放monitor所有权，
> monitor计数器减1。

##### 说说 Monitor
> 在JVM中，synchronized支持的同步方法和同步语句都是基于monitor来实现的。每个对象都与一个monitor相关联，当一个线
> 程执行到一个monitor监视下的代码块中的第一个指令时，该线程必须在引用的对象上获得一个锁，这个锁是monitor实现的。
> 在HotSpot虚拟机中，monitor是由ObjectMonitor实现，使用C++编写实现。    
> ObjectMonitor的主要的属性有：
_count(记录该线程获取锁的次数)、  
_recursions(锁的重入次数)、  
_owner(指向持有ObjectMonitor对象的线程)、  
_WaitSet(处于wait状态的线程集合)、   
_EntryList(处于等待锁block状态的线程队列)。   
当并发线程执行synchronized修饰的方法或语句块时，先进入_EntryList中，当某个线程获取到对象的monitor后，把monitor对象
中的_owner变量设置为当前线程，同时monitor对象中的计数器_count加1，当前线程获取同步锁成功。   
当synchronized修饰的方法或语句块中的线程调用wait()方法时，当前线程将释放持有的monitor对象，monitor对象中的_owner变
量赋值为null，同时，monitor对象中的_count值减1，然后当前线程进入_WaitSet集合中等待被唤醒。

##### 锁之间的区别，同步锁举例
> 同步锁：synchronized。

##### Lock原理
> 状态值 + AQS(双端阻塞队列) + CAS。多数使用它的实现类[ReentrantLock]。    
> 状态值记录线程是否获得锁。没有获得锁的线程构建成节点添加到同步队列，设置成尾结点，通过底层方法进入阻塞状态。设置尾结点
> 是需要保证线程安全的所以需要通过CAS完成。当上一个获得锁的线程释放锁后，队列唤醒头结点的线程，尝试获取锁。

##### synchronized和Lock(ReentrantLock)区别
> synchronized是一个关键字，Lock是一个接口；   
> synchronized能自动释放锁，Lock不会；   
> synchronized只能等待锁释放，Lock可以中断等待；   
> synchronized是独占锁，Lock可以实现为独占锁，也可以是共享锁；   
> synchronized是隐式锁(不需要手动加锁释放锁)，Lock是显示锁(需要手动加锁释放锁)。

##### synchronized是公平锁还是非公平锁，ReentrantLock是公平锁吗？
> synchronized是非公平锁，因为需要竞争，不是按照顺序。ReentrantLock可以实现为公平锁，也可以实现为非公平锁。通过AQS
> 实现锁资源竞争。队列是一个FIFO的双向链表，能满足有序竞争锁资源。

##### Synchronized在JDK1.6之后做了哪些优化
> 锁升级(从偏向锁到轻量级锁到重量级锁)。

##### JMM可见性，原子性，有序性，synchronized可以保证什么
> 可以保证可见性，原子性，有序性(多线程下顺序执行)

##### volatile了解吗
> volatile是Java虚拟机提供的轻量级的同步机制，它的特性有：能保证可见性、但不保证原子性、禁止指令重排。

##### 什么是指令重排序    
> 处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，
但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。

##### volatile如何保证可见性、禁止指令重排的原理是什么
> 可见性原理：jvm将.class文件编译成机器码后，使用volatile修饰的变量会在指令添加一个`Lock`前缀。有Lock前缀指令会导
> 致当前处理器缓存数据会写入到系统内存；而处理器把缓存写入到内存会让其他处理器的缓存失效，当发现这个变量的缓存失效时，会
> 从内存中重新读取。保证这个变量对于所有线程始终是最新值。
>
> 禁止指令重排的原理：在编译成字节码时，会在volatile变量指令前后插入内存屏障，禁止处理器重排序。

##### volatile字段有什么用途？
> 能保证可见性、不保证原子性、能够禁止指令重排(插入内存屏障)。

内存屏障类型(`Load`-代表读，`Store`代表写)

类型名称  |   指令  | 说明
:----  |   :----- | :----
LoadLoad | Load1;_LoadLoad_;Load2 | 确保`读取Load1操作`优先于`读取Load2操作`(以及Load2后面的)
LoadStore | Load1;_LoadStore_;Store2 | 确保`读取Load1操作`优先于`Store2写入到内存操作`(以及Store2后面的)
StoreStore | Store1;_StoreStore_;Store2 | 确保`Store1操作`优先于`Store2操作`写入到内存(以及Store2后面的)
StoreLoad | Store1;_LoadLoad_;Load2 | 确保`Store1写入到内存操作`优先于`读取Load2操作`(以及Load2后面的)

volatile的内存屏障策略插入策略会在这4个位置插入内存屏障，实现禁止指令重排。

##### synchronized和volatile的区别？为何不用volatile替代synchronized？
> volatile只能使用在变量上，synchronized可以使用在变量和方法与类级别上；   
> volatile不会造成线程阻塞，synchronized可能会造成线程阻塞；   
> volatile只能保证可见性，无法保证原子性，synchronized可以原子性和可见性；   
> volatile能禁止指令重排，synchronized不能禁止指令重排；
>

为何不用volatile替代synchronized
> volatile无法保证原子性，所以它无法替换synchronized。

有了synchronized为什么还要volatile
> synchronize不能保证单个线程内部指令的顺序，也就是指令重排，任然有线程安全问题。比如双重检查单例创建问题，为什么还使
> 用volatile。第二点就是还会阻塞，内部的隐式锁增加性能消耗。

##### volatile在DCL(Double Check Lock)上的作用是什么？
> 1、保证多线程情况下，线程之间的可见性(volatile 的第1个特性）；2、禁止指令重排序（volatile的第2个特性）

##### ReentrantLock的实现原理是什么
> CAS+AQS

##### AQS了解吗？
> `AbstractQueuedSynchronized`的缩写，又称抽象队列式同步器。作用是给java一系列锁以及同步器或者同步对象的底层提供
> 了实现的框架，一种规范。提供解决同步问题的基础框架。

AQS实现：
> 通过CLH同步队列完成同步状态的管理，如果线程获取同步状态(锁)失败时，AQS会将当前线程构造成一个节点加入
> 到CLH同步队列尾部，同时会阻塞当前线程。当同步状态(锁)释放时，会把首节点唤醒(公平锁)，使其再次尝试获取同步状态。
>
> CLH(Craig, Landin ,and Hagersten)：--同步(等待)队列，是一个FIFO双向队列，拥有pre前驱节点、next后驱节点。   
> FIFO(first-in-first-out)：--先进先出；

##### CAS如何保证原子操作,CAS原理
> CAS其实就是Compare And Swap的一个缩写。即把当前值与预期的值进行一个比较，如果一样再进行修改，否则不修改并返回失败。
> 整个比较并替换的操作是一个原子操作。

CAS本身操作的原子性保证
> 通过`循环CAS法`保证CAS是一个原子性操作。这里的CAS是指Unsafe中的CAS方法。很多CAS操作都是依赖Unsafe类完成。
> Unsafe中应用了循环CAS法。并且Unsafe的方法基本都是native方法。这些底层方法执行过程中在会被处理器添加Lock前缀(指
> 令的Lock前缀作用参考volatile)。总结：[Unsafe + 循环CAS + Lock前缀]

##### CAS会产生什么问题(ABA)
> 1、ABA问题：“如果一个值原来是A，后来修改成了B，然后又修改回为A。这时CAS就会认为它从来没有被改变过。可是实际上确实发生
> 了改变”，这一漏洞称之为“ABA问题”。`解决办法：---添加版本号。`如添加版本后：那么A -B -A就会变成1A -2B -3A。只有
> 版本号预期与预期值都相同时，认为成功。
>
> 循环时间长开销大：自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。
>
> 只能保证一个共享变量的原子操作：循环CAS的方式只能保证一个变量原子操作，当多个变量时可以`加锁`。甚至将多个变量当成一
> 个变量实现。

##### AtomicInteger如何保证原子操作
> CAS + Volatile。  
> UnSafe的作用：获取对象偏移量，拥有直接操作对象内存地址的能力。直接操作内存效率更高。

##### notify和notifyAll区别,锁池,等待池
> 等待池：线程调用了某个对象的wait()方法后，线程就会释放该对象的锁，然后进入到了该对象的等待池，等待池中的线程不会去竞
> 争该对象的锁。(释放了锁的线程)

> 锁池：线程去竞争已被获取了锁的对象时，线程就会进入到该对象的锁池。(等待竞争锁的线程)

> notify()：随机唤醒对象的等待池中的`一个线程`，进入锁池
> notifyAll()：唤醒对象的等待池中的`所有线程`，进入锁池