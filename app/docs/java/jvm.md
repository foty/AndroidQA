###JVM

* 内存模型(内存区域)
* 类加载机制
* 垃圾收集算法(GC)


####什么是jvm

JVM，即JavaVirtualMachine，Java虚拟机的缩写。是一种用于计算设备的规范，一个虚构出来的计算机。是处理java程序的核心，也是java跨平台的核心。
采用基于栈的架构，其指令由操作码和操作数组成。

jre：Java Runtime Environment。java运行环境，java平台，所有的java程序要在这个环境下才能运行。   
jdk：Java Development Kit。开发者开发，编译，调试程序的工具包。也需要在jre环境下才能运行。   


#### 内存模型

Java虚拟机的内存划分分2大类：

* 线程共享的：**方法区(元空间)**、**堆**
* 线程私有的：**程序计数器**、**虚拟机栈**、**本地方法栈(区)**

区域 | 共享状态 | 内容
:--- | :--- | :---
方法区 | 共享 | 被虚拟机加载的类，常量，静态常量，即时编译代码数据等，运行时常量池
(java)堆 | 共享 | 存放实例对象(通过new创建)，字符串常量池
虚拟机栈 | 私有 | java方法执行的内存模型，每个方法在执行时都会创建一个栈帧
本地方法栈(区) | 私有 | 与虚拟机栈类似，但这块是虚拟机使用到的Native方法
程序计数器 | 私有 | 当前线程所执行的字节码的行号指示器，记录当前线程执行的位置。

##### 堆

jvm中管理内存最大的一块，因为几乎所有对象实例都保存在这里，所以它也是java垃圾回收器管理的主要区域，也称“GC堆”。
GC堆按照存储时间不同可分
* 新生代(内部可分Eden、Survivor)
* 老年代

##### 常量池

常量池是一个大概念，**分有类常量池**(.class字节码文件中的内容)，**运行时常量池**(方法区)，**字符串常量池**(java堆)。

* 类常量池：是.class字节码文件中内容，一种文件概念，保存了Java类中大多数信息，如方法信息、变量信息等。

* 运行时常量池：是方法区中的一部分，当Class文件被加载到内存后，Java虚拟机将Class文件中的常量池里的内容转移到运行时常量池里(这些内容主要是编译期生
              成的各种字面量和符号引用)，运行时常量池是每个类都有一个。

* 字符串常量池：位于堆中，专门针对String类型设计的常量池，因为字符串会被大量使用，每声明一次都为它分配一次内存，会造成很大的空间浪费。


#### 类加载机制

类的生命周期：
* 装(加)载
* 验证
* 准备
* 解析
* 初始化
* 使用
* 卸载

其中`验证`、`准备`、`解析`又合称**链接**。   
加载，验证，准备，解析及初始化是属于类加载机制中的步骤，也就是一个class文件被加载到内存需要经历的步骤。

##### 1、加载
加载指的是java虚拟机查找class文件，生成字节流并根据字节流创建java对象，将对象作为方法区这个类的各种数据的访问入口的过程。

**1.1 类加载器**  

1.1.1 BootstrapClassLoader  

启动类加载器。c++实现，本身属于虚拟机的一部分，负责加载java的核心类。

1.1.2 ExtensionClassLoader(改名 PlatformClassLoader)  

扩展类加载器。负责加载\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库，即负责加载Java扩展的核心类之外的类。

1.1.3 ApplicationClassLoader  

应用程序类加载器：负责加载用户类路径(class.path)上的指定类库，可以直接使用这个类加载器。通过`ClassLoader.getSystemClassLoader()`方法直
接获取。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。

**1.2 双亲委派机制**  

当一个类加载器收到类加载请求的时候，它首先不会自己去加载这个类，而是把该请求委托给父类加载器，依次向上。因此所有的类加载请求最后都会被传递到顶层
的启动类加载器中，只有当父类加载器中无法加载到所需的类，子类加载器才会自己尝试去加载该类。如果当前类加载器和所有父类加载器都无法加载该类时，抛出
ClassNotFindException异常。

ClassLoader加载类源码：
```textmate
    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException
    {
            // First, check if the class has already been loaded
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }
                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    c = findClass(name);
                }
            }
            return c;
    }
```
总结如下：
* 首先检查类是否已经加载过，如果加载过，直接返回。
* 判断是否有父加载器，如果有，委托给父加载器加载；如果没有，直接调用启动类加载器加载；
* 如果父加载器与启动类加载器都无法加载到类，那就由当前的类加载器加载(findClass)

**1.2.1 双亲委派机制的好处(为什么要使用双亲委派机制)**

* 避免类的重复加载 
* 保护程序安全，防止核心API被篡改

##### 2、验证
**链接阶段**的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。包含四个阶段
的校验动作：
* 文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理
* 元数据验证：对类的元数据信息进行语义校验，是否不存在不符合Java语言规范的元数据信息
* 字节码验证：通过数据流和控制流分析，确定程序语义是合法，符合逻辑的。对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。
* 符号引用验证：确保解析动作能正常进行

##### 3、准备
正式为类变量分配内存并设置类变量初始值的阶段。这些变量所使用的内存都将在方法区中分配。只包括类变量。初始值通常情况下是数据类型的零值。

##### 4、解析
虚拟机将常量池内的符号引用替换为直接引用的过程。

##### 5、初始化
执行类构造器<clinit>()方法的过程。简单地说，初始化就是对类变量进行赋值及执行静态代码块。

##### 6、使用
就是使用对象。较少讨论这个步骤。

##### 7、卸载
从内存中释放，销毁。较少讨论这个步骤。


#### 垃圾回收算法(GC)

标记算法：标记待回收对象为垃圾的算法
回收算法：清除回收被标记的垃圾对象的算法逻辑

##### 标识(记)算法

垃圾回收机制

**引用计数法**
> 每个对象上都有一个引用计数。对象每被引用一次，引用计数器就+1，对象引用被释放，引用计数器-1，直到对象的引用计数为0，对象就标
> 识可以回收。缺陷就是对于循环引用的情况下，循环引用的对象就不会被回收。比如A,B只有相互引用，它们也不会回收。

**Root搜索算法(可达性算法)**
> 目前大部分JVM所使用的标记算法。以root对象集合中的root对象出发，进行自上往下的搜索，与根对象直接连接或间接连接的对象都可以被搜索。当
> JVM无法到达某个对象时，它会被标记为可清除对象。

根对象集合有：
* 虚拟机栈中的对象引用
* 方法区中的类静态属性的对象引用
* 运行时常量池中的对象引用
* 本地方法栈的对象引用
* 被启动类加载器加载的类和创建的对象

##### 1、标记-清除算法

标记-清除算法分为“标记”和“清除”两个阶段：
* 标记：通过标记算法，标记出所有需要回收的对象
* 清除：在标记完成后统一回收所有被标记的对象

**缺点：**    
* 效率问题，标记和清除两个过程的效率都不高。
* 空间问题，标记-清除会产生大量不连续的内存碎片，空间碎片太多会导致后续程序运行分配大对象时没有足够的连续内存空间(再次触发GC)。

##### 2、复制算法

* 首先将可用内存分为大小相等的两块，每次只使用其中的一块。
* 当一块的内存用完，将还存活的对象连续复制到另一块上面，然后把使用过的内存空间一次清理掉。

**特点：**  
> 相对于标记-清除算法，回收效率相对提高了。但是可用内存缩小到了原来一半。

**另外：**  
> 现代的商业虚拟机都采用这种收集算法来回收新生代，但不是按照1：1的比例来划分内存空间，而是将内存分为较大的Eden空间和2块较小的Survivor空间
，每次使用Eden和其中一块Survivor。回收时，将使用的survivor的存活对象复制到另外一块survivor空间，清理eden与使用过的survivor空间。    
HotSpot虚拟机中默认Eden和Survivor的大小比例是8：1。  

**缺点：**   
> 在对象存活率较高时，就要进行较多的复制操作，效率就会变低。

##### 3、标记-压缩(整理)算法

标记-整理算法分为“标记”和“整理”两个阶段：
* 标记：使用标记算法，标记出所有需要回收的对象
* 整理：让所有的存活的对象都向一端移动，然后直接清除掉边界以外的内存

**特点：**   
> 相对于标记-清除算法，解决了内存碎片问题；但因为要移动存活对象，一定程度上还是降低了效率。

##### 4、分代收集算法

将堆内存划分为`年轻代`和`老年代`(版本比较早时可能还有永久代的说法)，不同年代根据自身特性采用不同的垃圾收集算法。  
* 新生代：--每次GC时都有大量的对象死亡，只有少量对象存活。考虑到复制成本低，适合采用复制算法；
* 老年代：--因为对象存活率高，没有额外的内存空间对它进行担保。因而适合采用标记-清理算法或标记-整理算法进行回收；
* (永久代)：--持久代对垃圾回收没有显著影响；


<br>


#### 问题收集

new一个对象的流程?
> <https://blog.csdn.net/qq_36986015/article/details/113740499>

java中的类何时被加载器加载?
> java程序启动时，并不是一次性加载所有.class文件。而是在程序运行中动态加载相应的类到内存中。当一下2点触发时，.class文件会被加载器主动加载：
> 1、调用类构造器
> 2、调用类中的静态变量或者静态方法。