### 并发概念

- 并发三大特性(原子性、可见性、有序性)
- 锁的类型
- CAS (比较并交换)
- AQS (抽象队列同步器)
- synchronized与ReentrantLock
- volatile
- Monitor


1、并发编程的3大问题。
* 原子性(统一)。一系列操作流程下来，要么都成功，要么都不成功。例如：A给B转账100，对应的操作就是A-100，B+100。如果没
有原子性，只是单方面加或减必然产生问题。

* 可见性(及时)。多线程访问同一个变量时，一方面对变量修改，其他线程应该立即看到修改。

* 有序性。指程序按照先后顺序执行。这就涉及到内存模型了。我们的代码编写是有顺序的，到是放到JVM中执行却不一定按照代码顺
序来执行的。可能发生指令重排。

2、 指令重排序    
一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，
但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。

3、java内存模型只是保证了基本的读取和修改是原子性。如果需要更大范围内保证原子性，可以借助同步锁来实现。同步锁能使得同
一时刻只能有一条线程执行，由多线程转向 单线程，从而保证原子性。


#### 锁概念与分类
资料出处 <https://www.cnblogs.com/hustzzl/p/9343797.html>  
1.锁的各种分类有：
* 乐观锁/悲观锁
* 独享锁/共享锁
* 互斥锁/读写锁
* 可重入锁
* 公平锁/非公平锁
* 自旋锁
* 分段锁
* 偏向锁/轻量级锁/重量级锁

>1.1 乐观锁与悲观锁  
乐观锁： 如同字面意思，就是很乐观。每次访问时默认没有其他人修改，所以不会加锁。只是在更新时判断是否已经被更新过。常用的
实现方式有`版本号机制`与`CAS`。乐观锁适用于读取频率高的场合，可以提高吞吐量。    
悲观锁： 每次访问都是按照是最坏的情况来处理，也就是加上锁。这样其他人只能先拿到锁才能去访问数据。悲观锁适合写入操作频繁
的场景。如 synchronized。

“版本号机制”  
为一段数据增加一个版本号，每次修改数据并且更新版本号。在数据修改更新前，会先读取到版本号；提交修改时，只有更新前读取的
版本号与现阶段数据最新的版本号相等时才能提交成功。


>1.2 独享锁与共享锁  
独享锁： 是指该锁一次只能被一个线程锁持有。共享锁：是指该锁能被多个线程锁持有。独享锁与共享锁可以通过AQS来实现，通过不
同的实现方法，来实现独享或共享。像synchronized 就是一个独享锁。

>1.3 互斥锁/读写锁   
互斥锁/读写锁其实是独享锁/共享锁的一种具体体现。在Java中，互斥锁的实现有ReentrantLock。读写锁有ReadWriteLock。

>1.4 可重入锁  
可重入锁又名递归锁。指线程获取到锁后可以重复获取锁并且不会导致死锁。在java中有：ReentrantLock、synchronized。
 
>1.5 公平锁/非公平锁
公平锁就是多个线程之间通过申请顺序来获得锁权限。非公平锁则是指线程之间获得锁的顺序不是按照申请顺序。也就是存在“插队”现
> 象。synchronized是一种非公平锁。

>1.6 自旋锁  
指尝试获取锁的线程不会立即阻塞，而是通过循环的方式去尝试获取锁。这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。

>1.7 分段锁  
分段锁是一种设计理念。不表示某一种具体的锁。

>1.8 偏向锁/轻量级锁/重量级锁  
这3种名词是指锁的状态，特指synchronized。锁一共有4种状态：    
* 无锁
* 偏向锁：是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
* 轻量级锁：是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会
阻塞，提高性能。
* 重量级锁：是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到
锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入阻塞，性能降低。


#### Volatile  
用于修饰变量，能够保证有序性和可见性，不能保证原子性。
* 共享变量用volatile修饰时，它会保证修改的值会立即被更新到主内存，当有其他线程需要读取时，它会去内存中读取新值。(可见性)
* 禁止指令重排,通过插入内存屏障实现。(有序性)

> 可见性原理：    
> jvm将.class文件编译成机器码后，使用volatile修饰的变量会在指令添加一个`Lock`前缀。有Lock前缀指令会导
> 致当前处理器缓存数据会写入到系统内存；而处理器把缓存写入到内存会让其他处理器的缓存失效，当发现这个变量的缓存失效时，会
> 从内存中重新读取。保证这个变量对于所有线程始终是最新值。 

> 禁止指令重排的原理：   
> 在编译成字节码时，会在volatile变量指令前后插入内存屏障，禁止处理器重排序。

内存屏障类型(`Load`-代表读，`Store`代表写)

类型名称  |   指令  | 说明
:----  |   :----- | :----
LoadLoad | Load1;_LoadLoad_;Load2 | 确保`读取Load1操作`优先于`读取Load2操作`(以及Load2后面的)
LoadStore | Load1;_LoadStore_;Store2 | 确保`读取Load1操作`优先于`Store2写入到内存操作`(以及Store2后面的)
StoreStore | Store1;_StoreStore_;Store2 | 确保`Store1操作`优先于`Store2操作`写入到内存(以及Store2后面的)
StoreLoad | Store1;_LoadLoad_;Load2 | 确保`Store1写入到内存操作`优先于`读取Load2操作`(以及Load2后面的)

volatile的内存屏障策略插入策略会在这4个位置插入内存屏障，实现禁止指令重排。

#### Synchronized
用于同步代码块或者方法，能够保证原子性、可见性、有序性(通过阻塞实现按顺序执行)。是一种重量级别的锁。重量级锁会让它申请
的线程进入阻塞，影响效率。  

原理：   
> 对jmv层面的monitor对象加锁解锁实现同步。方法级别的同步是根据方法表中的同步标志判断是否是同步方法。如果是则会先去获
> 取monitor对象，执行完方法释放monitor对象；代码级别的同步是根据monitor-enter和monitor-exit指令完成。执行
> monitor-enter获取monitor对象，执行monitor-exit，释放monitor对象。

3.1 Monitor（管程/监视器）
> 前面知道synchronized是基于monitor机制实现的同步。直译为“监视器”，而操作系统领域一般翻译为“管程”。管程是指管理
> 共享变量以及对共享变量操作的过程，让它们支持并发。比如synchronized关键字和wait()、notify()、notifyAll()这三个方法
> 是Java中实现管程技术的组成部分。Monitor机制在Java中的实现就是ObjectMonitor。

3.2 在java与kotlin的使用
> 主要说说在kotlin中修饰方法的用法。并不是在方法中添加synchronized关键字，而是使用@synchronized注解。但是其原理是
> 一样的。

#### AQS  
`AbstractQueuedSynchronized`的缩写，又称抽象队列式同步器。是一套多线程访问共享资源的同步框架。里面维护一个由
volatile修饰的访问状态以及一个线程等待队列。可以通过实现不同的方法构造成不同类型的锁。如ReentrantLock就可以构成共享
锁或者独享锁。

#### CAS   
(Compare And Swap)比较并交换的缩写。CAS机制包含3个操作对象。1是需要更新的位置；2是预期值；3是新值。只有当需要更新
的位置上的值与预期值相等时，才会将需要更新位置上的值设置为新值。否则全部失败。

#### ReentrantLock (可重入锁)
happens 、before、 lost wake up.....


#### Synchronized和ReentrantLock的区别
- Synchronized是JVM层次的锁实现，ReentrantLock是JDK层次的锁实现；
- Synchronized的锁状态是无法在代码中直接判断的，但是ReentrantLock可以通过ReentrantLock#isLocked判断；
- Synchronized是非公平锁，ReentrantLock是可以是公平也可以是非公平的；
- Synchronized是不可以被中断的，而ReentrantLock#lockInterruptibly方法是可以被中断的；
- 在发生异常时Synchronized会自动释放锁（由javac编译时自动实现），而ReentrantLock需要开发者在finally块中显示释放锁；
- Synchronized在特定的情况下对于已经在等待的线程是后来的线程先获得锁（上文有说），而ReentrantLock对于已经在等待的
线程一定是先来的线程先获得锁；

  
#### 对象的结构
一个对象是由对象头、实例数据、对齐填充(padding)3部分组成。
* 对象头由两部分组成，第一部分存储对象自身的运行时数据：哈希码、 GC分代年龄、锁标识状态、线程持有的锁、偏向线程ID 
（一般占 32/64 bit ）。第二部分是指针类型，指向对象的类元数据类型（即对象代表哪个类）。如果是数组对象，则对象头中还
有一部分用来记录数组长度。
* 实例数据用来存储对象真正的有效信息（包括父类继承下来的和自己定义的）
* 对齐填充： JVM要求对象起始地址必须是 8 字节的整数倍（8字节对齐）


#### 常见问题

##### 说一下synchronized的作用。
> 对于单一JVM来说，synchronized可以保证在并发情况下，同一时刻只有一个线程执行某个方法或某段代码，它可用于修饰方法或
> 代码块，实现对同步代码的并发安全控制。

##### synchronized可用于修饰方法和代码块，他们有什么区别呢？
> 修饰方法在底层实现上是在方法访问标识中设置ACC_SYNCHRONIZED标示符；修饰代码块在底层实现上会使用monitor-enter和
> monitor-exit指令。

##### synchronized修饰方法方式的底层实现原理？
> 修饰方法通过编译后，会在方法表结构中设置ACC_SYNCHRONIZED访问标识。每个对象都与一个monitor相关联，当且仅当
> monitor被线程持有时，monitor会处于锁定状态，也就是加锁。当方法执行时，线程将先尝试获取对象相关联的monitor所有权，
> 然后再执行方法，最后在方法完成(无论是正常执行还是非正常执行)时释放monitor所有权。在方法执行期间，线程持有了monitor
> 所有权，其它任何线程都无法再获得同一个对象相关联的monitor所有权。

##### 说说对象头
> 对象头由以下几部分组成:
* 第一部分存储对象自身的`运行时数据(Mark Word)`：哈希码、 GC分代年龄、锁标识状态、线程持有的锁、偏向线程
ID(一般占 32/64bit)；
* 第2部分是`指针类型`，指向对象的类元数据类型（即对象代表哪个类）；
* 第3部分是`数组长度`，但是只在数组对象才会有；

##### 一个对象的锁状态存在哪里
> 在Java对象的对象头Mark Word(运行时数据)中。

##### synchronized修饰代码块方式的底层实现原理？
总结就是monitor-enter指令和monitor-exit指令以及monitor计数器实现。

> 添加synchronized修饰代码块，编译后会在逻辑代码前添加monitor-enter指令，在逻辑代码尾添加monitor-exit指令。当方法
> 执行时，当前线程执行monitor-enter指令获取对象相关联的monitor所有权。如果此时这个monitor的计数器是0，那么当前线程
> 持有该monitor，同时monitor计数器设置为1；如果当前线程已经持有了对象相关联的monitor所有权，只是想重新获取，那么继
> 续持有该monitor，同时monitor计数器加1；如果有其它线程已经持有了对象相关联的monitor所有权，当前线程会进入阻塞，直
> 到monitor计数器为0，再次尝试获取所有权。方法正常执行或发生异常时，会执行monitor-exit指令，释放monitor所有权，
> monitor计数器减1。

##### 说说 Monitor
> 在JVM中，synchronized支持的同步方法和同步语句都是基于monitor来实现的。每个对象都与一个monitor相关联，当一个线
> 程执行到一个monitor监视下的代码块中的第一个指令时，该线程必须在引用的对象上获得一个锁，这个锁是monitor实现的。
> 在HotSpot虚拟机中，monitor是由ObjectMonitor实现，使用C++编写实现。    
> ObjectMonitor的主要的属性有：
_count(记录该线程获取锁的次数)、  
_recursions(锁的重入次数)、  
_owner(指向持有ObjectMonitor对象的线程)、  
_WaitSet(处于wait状态的线程集合)、   
_EntryList(处于等待锁block状态的线程队列)。   
当并发线程执行synchronized修饰的方法或语句块时，先进入_EntryList中，当某个线程获取到对象的monitor后，把monitor对象
中的_owner变量设置为当前线程，同时monitor对象中的计数器_count加1，当前线程获取同步锁成功。   
当synchronized修饰的方法或语句块中的线程调用wait()方法时，当前线程将释放持有的monitor对象，monitor对象中的_owner变
量赋值为null，同时，monitor对象中的_count值减1，然后当前线程进入_WaitSet集合中等待被唤醒。  

##### 锁之间的区别，同步锁举例
> 同步锁：synchronized。

##### 锁的分类，锁的几种状态
> 可重入锁：线程获取到锁后可以重复获取锁并且不会导致死锁。在java中有：ReentrantLock、synchronized。
> 公平锁：多个线程之间通过申请顺序来获得锁权限
> 非公平锁：非公平锁则是指线程之间获得锁的顺序不是按照申请顺序
> 互斥锁：线程获取到锁后，其他线程再次获取锁会失败，然后释放cpu，进入阻塞状态(与自旋锁相反)
> 自旋锁：指尝试获取锁的线程后不会立即阻塞，而是通过循环的方式去尝试获取锁。

锁有四种状态，随着锁的竞争，锁的状态只有升级，没有降级。偏向锁->轻量级锁->重量级锁。
> 无锁    
> 偏向锁：特点是加锁和解锁不需要额外的消耗。但是如果有多个线程竞争，会带来额外的锁撤销消耗。适用于单线程环境。    
> 轻量级锁：特点竞争的线程不会阻塞，提高响应速度。但始终无法竞争到的线程会进入自旋消耗cpu。适用追求响应时间，执行速度
快的环境。     
> 重量级锁：特点是线程竞争不会自旋，不会消耗cpu。但线程会进入阻塞状态，响应慢。

##### 如何避免死锁
> 破坏产生死锁的4个必要条件。`互斥`，`不可剥夺`，`请求并持有`，`环路等待`。实际当中，第一、第二点无法或很难实现，所以
> 可以针对第3、4条件处理。比如保证请求资源的有序性，可以避免请求并持有条件；设置锁定时间，定时释放可以避免环路等待。

##### 平常有用到什么锁，synchronized底层原理是什么
> 是对jmv层面的monitor对象加锁解锁实现同步。方法级别的同步是根据方法表中的同步标志判断是否事同步方法。如果是则会先去获
> 取monitor对象，执行完方法释放monitor对象；代码级别的同步是根据monitor-enter和monitor-exit指令完成。执行
> monitor-enter获取monitor对象，执行monitor-exit，释放monitor对象。

##### Lock原理
> 状态值 + AQS(双端阻塞队列) + CAS。多数使用它的实现类[ReentrantLock]。    
> 状态值记录线程是否获得锁。没有获得锁的线程构建成节点添加到同步队列，设置成尾结点，通过底层方法进入阻塞状态。设置尾结点
> 是需要保证线程安全的所以需要通过CAS完成。当上一个获得锁的线程释放锁后，队列唤醒头结点的线程，尝试获取锁。

##### synchronized和Lock区别
> synchronized是一个关键字，Lock是一个接口；   
> synchronized能自动释放锁，Lock不会；   
> synchronized只能等待锁释放，Lock可以中断等待；   
> synchronized是独占锁，Lock可以实现为独占锁，也可以是共享锁；   
> synchronized是隐式锁(不需要手动加锁释放锁)，Lock是显示锁(需要手动加锁释放锁)。

##### synchronized是公平锁还是非公平锁,ReentrantLock是公平锁吗？是怎么实现的。
> synchronized是非公平锁，因为需要竞争，不是按照顺序。ReentrantLock可以实现为公平锁，也可以实现为非公平锁。通过AQS
> 实现锁资源竞争。队列是一个FIFO的双向链表，能满足有序竞争锁资源。

##### JMM可见性，原子性，有序性，synchronized可以保证什么
> 可以保证可见性，原子性，有序性(多线程下顺序执行)

##### volatile了解吗
> volatile是Java虚拟机提供的轻量级的同步机制，它的特性有：能保证可见性、但不保证原子性、禁止指令重排。

##### volatile如何保证可见性、禁止指令重排的原理是什么
> 可见性原理：jvm将.class文件编译成机器码后，使用volatile修饰的变量会在指令添加一个`Lock`前缀。有Lock前缀指令会导
> 致当前处理器缓存数据会写入到系统内存；而处理器把缓存写入到内存会让其他处理器的缓存失效，当发现这个变量的缓存失效时，会
> 从内存中重新读取。保证这个变量对于所有线程始终是最新值。
>
> 禁止指令重排的原理：在编译成字节码时，会在volatile变量指令前后插入内存屏障，禁止处理器重排序。

##### volatile字段有什么用途？
> 能保证可见性、不保证原子性、能够禁止指令重排(插入内存屏障)。

内存屏障类型(`Load`-代表读，`Store`代表写)

类型名称  |   指令  | 说明
:----  |   :----- | :----
LoadLoad | Load1;_LoadLoad_;Load2 | 确保`读取Load1操作`优先于`读取Load2操作`(以及Load2后面的)
LoadStore | Load1;_LoadStore_;Store2 | 确保`读取Load1操作`优先于`Store2写入到内存操作`(以及Store2后面的)
StoreStore | Store1;_StoreStore_;Store2 | 确保`Store1操作`优先于`Store2操作`写入到内存(以及Store2后面的)
StoreLoad | Store1;_LoadLoad_;Load2 | 确保`Store1写入到内存操作`优先于`读取Load2操作`(以及Load2后面的)

volatile的内存屏障策略插入策略会在这4个位置插入内存屏障，实现禁止指令重排。

##### synchronized和volatile的区别？为何不用volatile替代synchronized？
> volatile只能使用在变量上，synchronized可以使用在变量和方法与类级别上；   
> volatile不会造成线程阻塞，synchronized可能会造成线程阻塞；   
> volatile只能保证可见性，无法保证原子性，synchronized可以原子性和可见性；   
> volatile能禁止指令重排，synchronized不能禁止指令重排；
>

为何不用volatile替代synchronized
> volatile无法保证原子性，所以它无法替换synchronized。

有了synchronized为什么还要volatile
> synchronize不能保证单个线程内部指令的顺序，也就是指令重排，任然有线程安全问题。比如双重检查单例创建问题，为什么还使
> 用volatile。第二点就是还会阻塞，内部的隐式锁增加性能消耗。

##### AQS了解吗？
> `AbstractQueuedSynchronized`的缩写，又称抽象队列式同步器。作用是给java一系列锁以及同步器或者同步对象的底层提供
> 了实现的框架，一种规范。提供解决同步问题的基础框架。

AQS实现：
> 通过CLH同步队列完成同步状态的管理，如果线程获取同步状态(锁)失败时，AQS会将当前线程构造成一个节点加入
> 到CLH同步队列尾部，同时会阻塞当前线程。当同步状态(锁)释放时，会把首节点唤醒(公平锁)，使其再次尝试获取同步状态。
>
> CLH(Craig, Landin ,and Hagersten)：--同步(等待)队列，是一个FIFO双向队列，拥有pre前驱节点、next后驱节点。   
> FIFO(first-in-first-out)：--先进先出；

##### AtomicInteger如何保证原子操作
> CAS + Volatile。  
> UnSafe的作用：获取对象偏移量，拥有直接操作对象内存地址的能力。直接操作内存效率更高。

##### CAS如何保证原子操作,CAS原理
> CAS其实就是Compare And Swap的一个缩写。即把当前值与预期的值进行一个比较，如果一样再进行修改，否则不修改并返回失败。
> 整个比较并替换的操作是一个原子操作。

CAS本身操作的原子性保证
> 通过`循环CAS法`保证CAS是一个原子性操作。这里的CAS是指Unsafe中的CAS方法。很多CAS操作都是依赖Unsafe类完成。
> Unsafe中应用了循环CAS法。并且Unsafe的方法基本都是native方法。这些底层方法执行过程中在会被处理器添加Lock前缀(指
> 令的Lock前缀作用参考volatile)。总结：[Unsafe + 循环CAS + Lock前缀]

##### CAS会产生什么问题
> 1、ABA问题：“如果一个值原来是A，后来修改成了B，然后又修改回为A。这时CAS就会认为它从来没有被改变过。可是实际上确实发生
> 了改变”，这一漏洞称之为“ABA问题”。`解决办法：---添加版本号。`如添加版本后：那么A -B -A就会变成1A -2B -3A。只有
> 版本号预期与预期值都相同时，认为成功。
>
> 循环时间长开销大：自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。
>
> 只能保证一个共享变量的原子操作：循环CAS的方式只能保证一个变量原子操作，当多个变量时可以`加锁`。甚至将多个变量当成一
> 个变量实现。

##### notify和notifyAll区别,锁池,等待池
> 等待池：线程调用了某个对象的wait()方法后，线程就会释放该对象的锁，然后进入到了该对象的等待池，等待池中的线程不会去竞
> 争该对象的锁。(释放了锁的线程)

> 锁池：线程去竞争已被获取了锁的对象时，线程就会进入到该对象的锁池。(等待竞争锁的线程)

> notify()：随机唤醒对象的等待池中的`一个线程`，进入锁池
> notifyAll()：唤醒对象的等待池中的`所有线程`，进入锁池