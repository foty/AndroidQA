
### 1、基础知识

##### 说说  ==、equals 和 hashcode
简单说说，无非是什么，有什么用，有什么区别。参考回答：
> 它们都是用来判断对象是否相等。
> 不同点：`双等号(==)`对于基本数据类型，只要它们的值相同，结果就是true，否则false。对于非基本数据类型对象，是判断
> 是否为同一个内存地址，同一个引用；`equals`是Object中的方法，并且Object中equals默认使用==来判断，判断内容是否相
> 同，也就是值比较，==是引用比较；  
> equals与hashcode也是比较2个对象内容是否相等，并且都是Object中的方法。如果2个对象相等，hashcode一定相等，equals
> 也是返回true；如果只有equals相等，2个对象也是相等，它们的hashCode()也一定相等；如果只有hashcode相等，2个对象不
> 一定相等，equal也不一定相等。equal对应是准确性，hashcode对应是效率。

##### 为什么有了equals(hashcode)还要hashcode(equals)。
> 因为重写equal比较全面、复杂，效率就变低，而利用hashCode进行对比，只要生成一个hash值进行比较就可以，效率比较高。 
> 
> 因为hashCode并不完全可靠，有时候不同的对象他们生成的hashcode也会一样。(java中的hash函数返回的是int类型，对于
> hashcode的计算也是有限的，数据量大就有可能出现相同的hash值)

##### equals 和 hashcode如何协调比较。
> 当需要对比的时候，首先用hashCode去对比，如果hashCode不一样，则表示这两个对象肯定不相等，就不必再用equal去比较；
> 如果hashCode()相同，再对比他们的equal()。如果equal()也相同，则表示这两个对象是相同的。这样既能提高效率也能
> 保证准确性。

##### equals、hashcode为什么必须重写,只重写一个会怎样。
只重写一个无法保证准确性，无法满足所有需求，还会引发其他错误。
> 只重写equal，那么2个对象比较的就是hashcode，这个值是由内存地址转化而来，不同对象一定不同。这会导致创建的2个对象所
> 有属性都相同，但是因为hashcode没有重写，程序识别为2个不同的对象。即是equals相等了，hashcode也不等，违反hashcode
> 规则。  
> 只重写hashcode，那么比较的其实是对象的地址值(equals默认==实现)，不同对象也一定不同，甚至可以说2个对象永远不会相
> 等；

##### HashMap和HashSet为什么必须同时重写hashcode和equals。
> 一是hashcode和equals只重写其中一个都无法保证HashMap与HashSet内元素的准确性，就是无法判断2个对象是否相等；   
> 二会导致hash容器无法正常工作。(hash表是以key-value保存数据，key就是根据对象hashcode计算而来：
> 计算key下标的方式：(n - 1) & hash，n是数组长度。只重写equals会导致hashcode出现相同，导致无法保证key的唯一性)；
> 只重写hashcode会导致2个不同对象会被挂载到同一个key上，后挂载的会替换前挂载的，导致使用key获取的不是同一个对象。)

##### HashCode的作用
> 对象区别于其他对象的标识,hashcode是当前对象的地址值计算转化来的。

##### Switch能否用string做参数
> Java 1.7之前只能支持byte、short、int、char或其封装类及enum类型，1.7及以上才支持string，boolean类型也是不支持

##### java基本数据类型有哪些，int，long占几个字节
> 4类8种。
> 整数类(byte[1个字节，-128~127]、short[2个字节，-32768~32767]、int[4个字节，-2的31次方~2的31次方-1，约21亿]、
> long[8个字节])；   
> 浮点类(float[4个字节]、double[8个字节])、   
> 字符类(char[2个字节])、  
> 布尔类(boolean[占1位]);除此外都是引用数剧类型。  

##### Java面向对象的三个特征与含义。
> 封装：把客观事物封装成类或对象，隐藏对象的属性和实现细节，对外提供接口访问；   
> 继承：让某个类型的对象获得另一个类型的对象的属性和方法。继承导致类之间有分等级层次，子类可以继承父类的特征和行为，使
> 得子类具有父类相同的属性和行为；   
> 多态：同一个行为，不同的子类对象具有不同的表现形式。只有在运行的时候才知道引用指向的是哪个类的实例对象，以及引用调
> 用的方法指向的是哪个类中实现的方法。比如`重载`跟`重写(覆盖)`，父类引用指向子类实例等等。

##### java有什么特性，继承有什么用处，多态有什么用处。
> 封装：对内部数据提供了不同级别的保护，代码重用；
> 继承：扩展已存在的类或对象，代码重用；
> 多态：增加类或对象使用的灵活性和扩展性；

##### java为什么能做到多态
> 只有在运行的时候才知道引用指向的是哪个类的实例对象，以及引用调用的方法指向的是哪个类中实现的方法(运行时类型判定)。
> 因为    
> 1、类之间的继承关系。  
> 2、方法的重载跟重写。   
如果子类改写了父类的方法，那么子类和父类的同名方法共享一个方法表项，都被认作是父类的方法。在调用子类方法时，通过解析子
类实例方法获取对应方法表中的偏移量，通过偏移量找到实际的方法。

##### Override和Overload的含义去区别。
> Override：重写/覆盖。方法名、参数、返回值与父类完全相同。存在与父类子类之间；   
> overload：重载。方法参数的类型、个数、顺序至少有一个不相同。存在同个类的方法与方法之间；

##### String s = new String("xx")创建了几个对象
> 1个或者2个。如果常量池存在"xx",就是创建了1个，如果常量池不存在"xx",就是2个(引用对象s不算)。[]

##### new String("a") + new String("b")有几个对象
> 6个。分别是 new StringBuilder(拼接的默认使用StringBuilder拼接)，常量池a，堆内存a(new String(a))，常量池b，
> 堆内存b，堆内存ab。[注意，常量池内没有"ab"]

##### String的intern()会发生什么
> jdk1.6，如果常量池存在该对象，不会再次放入池，返回`常量池对象地址`；如果不存在，复制一份`对象`放入常量池。返
> 回`常量池对象`。(相当于有2个对象，2个对象不是同一个)。   
> jdk1.7及以上，如果常量池存在该对象，不会再次放入池，返回`常量池对象地址`；如果不存在，复制`对象引用`放入常量池，返
> 回`常量池的引用`。(常量池的是原对象的引用地址，都是同一个对象)

##### String是最基本的数据类型吗
> 不是。

##### 是否可以继承String类
> 不能，String是final修饰的，实现细节不允许改变。

##### 为什么final不能被继承
> 在java中，final关键字是“这是无法改变的”或者“终态的”含义。规定无法被它修饰的类无法继承，可能是出于设计或者效率。

##### String、StringBuffer与StringBuilder的区别。
都可以用来表示字符串。
> String是固定长度字符串，即是有拼接操作也是返回创建新的字符串对象；而StringBuffer与StringBuilder是可变字符串，
> 可以在原对象基础上拼接，对象不会改变(原因是它们内部使用char数组拼接处理)；所以String做拼接效率很低。String适用于
> 少量的字符串操作，StringBuffer与StringBuilder适用于大量字符串操作。    
> StringBuilder是线程不安全的，单线程环境表现突出。StringBuffer是线程安全的，多线程环境下表现突出。(内部的char数
> 组基础容量是16，每次扩容为增加原来一倍+2)

##### &和&&的区别？
> & 属于位运算，按位与，&&属于逻辑运算，逻辑与。   
> &&有短路功能，即第一个表达式为false时，整个结果就是false，不再判断第二个表达式；&没有短路功能

##### 值传递与引用传递？java是引用传递还是值传递
值传递和引用传递的区别并不是传递的内容，而是实参到底有没有被复制一份给形参。
> 值传递：复制一份变量传递给其他变量，在方法中修改并不会改变原始变量的值；引用传递：直接传递对象的地址，修改会改变对象
> 本身的值。    
> java是值传递，没有引用传递。对于基本数据类型，是传递对象量值的副本；对于引用类型，是该对象在内存中的地址值的副本。

##### int和Integer区别
> Integer是int的包装类；int是基本数据类型;   
> Integer变量必须实例化后才可以使用，而int变量则不需要;  
> Integer的默认值是null，而int的默认值为0.

##### char类型变量中能不能存贮一个中文汉字
> 可以。char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含汉字。如果某个汉字没有被包含在unicode编码
> 字符集中，那么这个char型变量就不能存储这个汉字。unicode编码占用两个字节；char类型的变量也是占用两个字节。

##### try catch finally，try里有return，finally还执行么
> 会执行。但是finally无法改变返回值。因为在执行的过程中, 如果try执行到return,会先将结果保存在一个临时变量中,等
> 到finally执行完毕之后再将保存的值取出返回。

##### java中静态方法，能不能被子类重写？编译会报错么
> 不能重写。静态方法只与类有关系，跟实例对象没有关系。重写是为了多态，静态方法在加载时就绑定了类，不存在父类引用指向子
> 类实例，也就不存在多态。但是子类可以声明与父类相同参数，同名的静态方法，但是这个类是绑定子类的，不能加重写注解。

##### 在一个静态方法内调用一个非静态成员为什么是非法的？
> 静态方法是跟随类的，随类的加载而加载；而非静态方法属性是属于对象的，对象是在类加载完后创建生成的。对象没有生成，非静
> 态成员当然也不存在。只依赖于类而不依赖于对象的静态方法自然不能调用一个不存在的方法，也不知道哪个对象，哪个成语变量。

##### 静态类与非静态类的区别。
> java中，静态类只能是内部类，因为外部类无法用static修饰。
> 看下面内部类特点。

##### 匿名内部类的特点
> 匿名内部类可以访问外部内的所有成员，外部类不能访问内部类的属性、方法   
> 匿名内部类不能访问外部类未加final修饰的变量(jdk1.8即使没有用final修饰也可以访问)   
> 匿名内部类中不能定义静态属性、方法   
> 内部类的隐藏属性this、super都是指向内部类自己。

##### 匿名内部类能不能访问外部类的私有方法(属性)？为什么
> 可以。内部类总有一个隐式引用指向外部类，在编译过程中，编译器会为外部类的私有属性生成静态方法。

##### 匿名内部类编译后也是独立的外部类，它为何能访问外部类的私有方法？如果能访问，怎么做到的？
> 内部类总有一个隐式引用指向外部类，在编译过程中，编译器会为外部类的私有属性生成相应的静态方法。

##### foreach与正常for循环效率对比。
> foreach效率更高。foreach只能用于遍历，不能更改循环目标，遍历速度快，执行效率高。for循环可以用于任何形式的重复行
> 为，在循环体中可以进行任何操作，所以遍历速度慢，执行效率低。

##### 装箱和拆箱的原理
> 装箱：自动将基本数据类型转换为包装器类型，调用`valueOf()`完成装箱；    
> 拆箱：自动将包装器类型转换为基本数据类型，调用了`***Value()`完成拆箱；   


### 2、数据结构、集合容器

HashMap系列 [](../data_structure/HashMap.md)   
ArrayList部分  [](../data_structure/ArrayList.md)

##### ArrayList、LinkedList、Vector的区别
> ArrayList：使用可变数组实现，可以添加任何元素，包括null；  
> Vector：几乎与ArrayList一样，但是Vector是线程安全的；  
> LinkedList：双向链表实现，可以添加任何元素，包括null；

##### Map、Set、List、Queue、Stack 的特点与用法。
> Map：以key-value键值对结构存储元素；key唯一，value可以重复；元素可以无序(hashMap)，也可以有序(LinkedHashMap)   
> List：保存元素有序；允许重复元素，可以通过下标访问元素；   
> Set：保存元素元素唯一，可以排序(treeSet)；  
> Queue：先进先出；
> Stack：先进后出；

##### 链表的查找的时间复杂度是多少
> O(n)，因为链表始终需要按照顺序一个一个查找对比。

##### TreeMap、HashMap、LinkedHashMap的区别。
> HashMap：根据key的HashCode值存储数据，有很快的访问速度，取出的数据的顺序是随机的
> LinkedHashMap：内部有双向链表，存取元素时有序的(保存顺序与取出顺序一样)；
> TreeMap：基于红黑树实现，具有排序功能,默认是自然排序(升序)

##### 讲讲LinkedHashMap的数据结构，实现按顺序存取的原理。
> 继承HashMap，实现Map接口。内部维护代表链表头尾节点的两个对象，并且重写HashMap创建节点的方法，在调用父类put()添加
> 元素创建节点时，控制头尾结点，完成链表元素添加。当删除元素时也是先删除hash表上的元素，然后再通过重写方法移除节点。

##### ConcurrentHashMap
产生原因、区分jdk7跟jdk8的区别
> 因为HashMap是非线程安全的，在并发情况下存在很大的隐患(多线程扩容时，链表可能会出现死循环)；HashTable虽然是线程安
> 全的，但是因为它所有的get/put都添加了synchronized，导致性能非常差。于是ConcurrentHashMap便出现了。    

jdk1.7版本：
> 底层数据结构是数组和链表。但是与HashMap不同的是引入了一个`Segment`的东西。Segment本身就像是一个HashMap，还继承
> ReentrantLock。HashMap的底层结构是个Entry数组，里面的元素是一个链表的表头，而ConcurrentHashMap的底层结构是
> Segment数组，每个Segment包含一个Entry数组，每个元素都是一个链表的表头。像个二级HashMap。
> 
> 结构好处：使用分段锁技术，实现真正的并发。[多线程环境下，不同Segment之间读写互不影响；同一个Segment下的读取、一读
> 一写也能并发执行，写入并发时需要获取锁，否则阻塞。]坏处是查找过程要比普通的HashMap要长。      
> 
> 查找数据：需要进过2次查找，第一次定位到Segment，第二次定位到元素所在Segment内部数组元素，也就是对应链表的表头。  
> 
> 统计元素size：首先遍历所有的Segment，统计元素数量以及发生修改次数。当修改总数与上次统计一样时，说明没有修改，当前
> 统计的数量就是map内的总数量，统计结束；当不一样时，重新统计，统计计数器+1。当统计次数到一定数量(3次)时，对每个
> Segment加锁，再次统计，最后返回总数(加锁后无法再修改，所以前后修改次数是相同的)。     
> 原因：上来就直接锁住所有Segment，统计完再解锁。这样做会影响到Map的其他读写操作，不利于并行。

jdk1.8：
> 底层数据结构：为了提高并发性，放弃分段锁的方案；采用数组+链表+红黑树的数据结构，与HashMap一样。采用CAS+
> synchronized保证线程安全

##### HashMap和ConcurrentHashMap的区别
> 最大区别就是HashMap线程不安全、ConcurrentHashMap线程安全。

##### 二分搜索树的特性和原理
特性
> 每个节点的值都小于其右子树的所有节点的值；   
> 每个节点的值都大于其左子树的所有节点的值；     
> 每一棵子树也是二分搜索树；

##### 堆的实现，最大堆，最小堆，优先队列原理
> 堆的实现：使用优先队列(java自带的API PriorityQueue)、使用数组

优先队列
> 优先队列是一种特殊的队列，为元素赋予优先级，具有最高优先级的元素成为队列头部，一般分最大优先队列、最小优先队列。通过
> 下沉或上浮操作，保存队列头部始终最大或最小。

##### Comparable和Comparator的区别
> 所在包类不一样：comparable在`java.lang`包下，comparator在`java.util`包下   
> 实现重写方法不一样；实现comparable要重写compareTo(T o)方法；实现comparator要重写compare(T o1,T o2)方法；   
> Comparable是排序接口，实现它的类意味着自己本身具有比较功能，将自己与另外一个对象比较排序；Comparator是比较接口，
> 实现它的类能够将两个不同对象比较，自己本身无法比较排序。Comparable相当于内部比较器，而Comparator相当于外部比较器

##### LRU算法实现
> Least Recently Used的缩写，即最近最少使用法则。   
> 实现：使用双向链表+同步机制(比如Hashtable)或者LinkedHashMap。最近命中或新添加的放在头部，链表尾部的将会在容量
> 满时被移除。

##### ArrayMap和SparseArray
> SparseArray：使用2个数组(key数组+value数组)，key指定为int类型，不需要hash值，基于二分查找存取数据，提高查找效
> 率。它的删除也不是真正移除元素，而是设置一个删除标志。存储基本类型数据，避免数据的装箱拆箱，某些情况下性能更好。对
> 比HashMap，以时间换空间。它的出现是为了节省内存以及提高效率。不需要创建节点消耗内存。但也因为需要移动数组会消耗性
> 能，所以只适用数据量很小的情况。
> 
> ArrayMap：类似ArrayMap，使用2个数组，mHashes和mArray。mHashes记录所有key的hashcode值；mArray记录所有
> key-value键值对，也都是基于二分查找存取数据。对比HashMap，同样不需要创建节点，节约内存，数据量小时查找效率更高，
> 不是和数据量大的环境。   
> ArrayMap解决hash冲突：向后追加。比如在位置i发生碰撞，则将i后的数据往后移，在i+1位置插入数据。mHash中相同的
> hashcode都是连接在一起的。


### 3、泛型 
[文档](../java/泛型.md)

##### 泛型常用特点，泛型有什么优点
> 性能高。存储值类型或转换为值类型时不需要装箱和拆箱；  
> 代码简洁方便。内部的转换都是自动和隐式的，省略强制转换代码；
> 类型安全。编码时限定了类型，只要编译时期没有警告，运行时就不会抛出类型转换异常，把运行时的问题提前到编译时期。

##### List< String>能否转为List< Object>
> 不行。因为泛型存在类型擦除，在编译后都会变成List，无法区分。还有String是Object的子类型，但是List< String>不是
> List< Object>的子类型，二者无法直接转换。

##### 泛型是怎么解析的，比如在retrofit中的泛型是怎么解析的
> Gson[GsonConverterFactory]

##### 泛型为什么要擦除？泛型的pecs原则
> 为了向后兼容，让使用泛型的代码可以和没有使用泛型的代码随意互用。

PECS：
> 要从泛型类取数据时，用extends;   
> 要往泛型类写数据时，用super;    
> 既要取又要写，就不用通配符(即extends与super都不用)。  

##### 为何会有协变和逆变
> java泛型是不变的。但是为了让泛型能变的像普通类一样具有继承关系。实现逆变与协变，就是利用通配符?。

##### 通配符
泛型的通配符是用于`解决泛型之间引用传递问题的特殊语法`, 在逻辑上还原了泛型类传入数据类型的参数父类子类的继承关系，同时
也可以按照需求设定通配符的上限与下限。
> 无边界通配符，写作`?`，表示可以是任何类型；    
> 固定上边界通配符，写作`? extend T`，表示必须是T或者T的子类类型；   
> 固定下边界通配符，写作 `? super T`，表示必须是T或者T的超类(父类)   


### 4、线程、多线程、线程池、同步
[文档](../java/并发(锁).md)

##### 实现多线程的两种方法。
> 继承Thread类或实现Runnable接口。

##### 创建线程的几种方式
> 继承Thread类、实现Runnable接口、创建Callable接口的实现类、使用线程池。

##### 线程的几种状态
> 新建、就绪、运行、死亡、堵塞。

##### 怎么中止一个线程，Thread.Interrupt一定有效吗
> 1、设置flag，让run()提前结束。   
> 2、使用stop()方法强行终止线程。   
> 3、使用interrupt()方法.

interrupt()一定有效吗
> 通过调用interrupt()方法是将isInterrupt标志位变成true，当run方法知道到该标志位时就会抛出异常达到终止线程的目的。理
> 论上是有效的。

##### wait()和sleep()的区别
> sleep不释放锁，wait释放锁;   
> sleep是Thread的方法，wait是Object的方法;

##### interrupt()、interrupted()、isInterrupted() 区别
> interrupt()：改变中断状态，它不会中断一个正在运行的线程。返回值时void。   
> interrupted()：测试是否中断，返回当前线程的中断标志位(boolean值)，并设置中断标志位为false；   
> isInterrupted()：测试是否中断，返回线程对象的中断标志位。

##### start()、run()的区别
> start()是启动一个线程，run()只是调用一个方法。 
> run()可以重复调用，start()不可以。   
> start()实现了多线程，run()没有实现多线程。

##### 多线程存在哪些问题
> [原子性问题]：A给B转账100，对应的操作就是A-100，B+100。如果没有原子性，只是单方面加或减,必然会产生问题。     
> [可见性问题]：多线程访问同一个变量时，一方面对变量修改，其他线程应该立即看到修改，如果不及时也必然会产生问题。   
> [有序性问题]：主要是jvm为了提高效率，会改变程序语句的执行顺序。比如双重检查创建单例对象。程序顺序是先分配内存、然后初
> 始化、最后将内存地址给单例对象。然而经过jvm的优化后，顺序变成了先内存地址给单例再初始化。造成的结果就是单例对象没有
> 初始化，引发空指针异常。    
> [死锁]。

##### 并发和并行区别
> 并行： 指两个或多个事件在同一时刻发生；   
> 并发： 指在同一时刻，只能有一个事件执行，但多个进程原因被快速轮换执行，使得宏观上具有多个事件同时执行的效果。   
> 举个例子：并发是一个人同时吃三个馒头，而并行是三个人同时吃三个馒头。

##### 线程池核心参数  
> `corePoolSize`核心线程数量，`maxPoolSize`最大线程数量，`keepAliveTime`线程存活时间，`unit`存活时间单位，
> `workQueue`工作队列，`threadFactory`执行器创建新线程时使用的工厂，`handler`拒绝策略。

##### 为什么用线程池
> 节约资源。重用线程，减少新建-销毁线程的开销，还能有效控制线程并发数量，避免线程间抢占系统资源而导致阻塞；   
> 能够统一管理；

##### 线程池了解多少？拒绝策略有几种,为什么有newSingleThread
> 4种拒绝策略。简述为：拒绝无处理、拒绝并抛异常、直接执行、抛弃最旧的任务执行新任务。  

为什么有newSingleThread(newSingleThreadExecutor)
> 这是一个单一线程池。corePoolSize为1，maximumPoolSize为1，keepAliveTime为0，阻塞队列使用的是
> LinkedBlockingQueue。该线程池的特点是保证了所有任务的执行顺序按照提交顺序来执行。

##### ThreadLocal的设计理念与作用。
> 理念：在多线程并发执行过程中，为了保证多个线程对变量的安全访问。   
> 作用：使变量在每个线程中都有独立值，不会出现一个线程读取变量时被另一个线程修改的现象。   

##### 如何配置线程池的？核心线程数一般是怎么配置的
> 考虑CPU核心数，再看是CPU密级型任务还是IO密级型任务。如果是CUP密集型，核心线程数 = CPU核数即可。也可以设置为CPU核
> 数+1，达到最大利用率。如果是IO密集型任务，则跟CPU计算速度和IO读写速度相关，可以分别计算2者的一个比值关系乘以cpu核数。

##### 如何让两个线程循环交替打印
> 常规方法，[while阻塞+flag]。声明一个flag，2条线程，一条线程flag为true时打印，一条为false时打印。中间使用while阻
> 塞，每次打印完将flag设置为对方的flag打印状态。

例子看[Bb.testNormal()]

##### 三个线程依次打印，有哪些方式
> [flag+while阻塞+ReentrantLock+Condition]。flag控制打印线程顺序，ReentrantLock控制线程加锁与释放锁，while，
> Condition控制阻塞与唤醒。每当一条线程打印完，唤醒下一条需要打印的线程并且释放锁。

例子看[Bb.print3()]

##### 谈谈线程死锁，如何有效的避免线程死锁？
> 死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象。产生死锁的必要条件有：
> 1、互斥条件(某个资源被一条线程使用时，其他线程无法使用)；   
> 2、不可剥夺(线程获取到的资源在自己使用完之前无法被其他线程占用，只能自己使用完后自己释放)；   
> 3、请求并且持有条件(一个线程持有了一个资源，又去请求新资源，但新资源被已被占用，自己陷入阻塞又无法释放持有资源)；   
> 4、环路等待条件(发生死锁时，必然存在一个等待资源线程--占用资源线程的环形链)

避免死锁
> 破坏死锁的4个必要条件即可避免死锁。第一、第二非程序本身能够控制，所以只能破坏第三、第四个条件之一。比如：  
> 保证资源使用的有序性能破坏请求并持有条件，设置等待时间、定时锁可以避免一直阻塞无法释放破坏环路等待条件。

##### 如何实现多线程中的同步
> synchronized同步方法、同步代码块、使用Volatile、使用重入锁(ReentrantLock)

##### 何为阻塞队列
> 阻塞队列是一个支持两个附加操作的队列。这两个附加操作是：在队列为空时，获取元素的线程会等待队列变为非空;当队列满时，
> 存储元素的线程会等待队列可用。

##### 为什么会有线程安全？如何保证线程安全
> 因为系统调度线程具有随机性，会导致数据操作的原子性、可见性、有序性无法保证而产生bug，这时线程就是不是安全的。保证
> 原子性、可见性、有序性的就是线程安全。   

如何保证线程安全
> 使用synchronized、Lock锁(如[ReentrantLock])保证线程同步；使用volatile保证可见性，禁止指令重排(有序性)


### 5、锁
[资料](../java/并发(锁).md)


### 6、加密

##### 有用过什么加密算法？AES,RAS什么原理？
> 对称性加密算法AES、非对称性加密算法RSA。   
> AES：过程涉及到`字节替代`、`行移位`、`列混淆`和`轮密钥加`4种操作，按照相反的顺序进行解密即可恢复明文。特点： 运算
> 速度快，安全性高，资源消耗少。
> 
> RAS：公钥、私钥。特点：安全、进行数字签名认证。

##### 对称加密和非对称加密，说说公钥
对称加密：
> 双方都持有同一个密钥，发送方用这个密钥按照指定的算法将数据加密，再发出去；接收方用这个密钥将接收到的数据解密，以得到
> 真实的数据含义。由于双方都持有这个密钥，而且内容相同，所以叫对称密钥。常见的有`DES`、`AES`、`RC4`等。

非对称加密：
> 该加密方式的密钥是一对，即公钥，私钥。其中，公钥可以随意发布，而私钥只有自己知道。发送方用公钥将数据加密，再发出去；
> 接收方用私钥将数据解密得到真实数据。两把钥匙不一样，所以叫做非对称密钥加密，也叫做公开密钥算法。常见的
> 有`RSA`、`DSA/DSS `。

公钥：
> 公钥一般是公开的，并且由公钥加密的只有私私钥才能解密。


### 7、反射
[](../java/反射.md)

##### 反射的作用与原理。
> 在运行时判断任意一个对象所属的类、一个类所具有的成员变量和方法；造任意一个类的对象，调用任意一个对象的方法以及动态代理。

原理：
> 利用Class对象。可以获取与类相关的各种信息， 提供了获取类信息的相关方法

##### 什么是反射。
> 在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意一个方法和属性。这
> 种动态获取信息及动态调用对象方法的功能(机制)叫做反射。

##### 怎么利用反射创建一个对象。
> 首先获取到Class对象；然后调用它的`newInstance()`创建实例。

##### 反射机制的优缺点
优点：   
> 1、提高程序的灵活性和扩展性，降低代码的耦合性。   
  2、通过反射机制在程序运行时可以操作类对象。   
  3、成为构建框架技术的理论基础   

缺点：  
> 1、性能问题；    
> 2、安全问题；  

##### 反射可以反射final修饰的字段吗
> 可以。但是不能保证正确访问到修改后的数据。因为存在内联优化。基本类型、String类型直接赋值时，jvm会编译优化，反射获
> 取的始终是旧值。[String类型直接赋值进到的常量池]    
> 无法直接修改同时被static final修饰的变量，可以先反射去掉final。

##### Class.getField()和getDeclaredField()的区别，getDeclaredMethod()和getMethod()的区别
> getField是仅获取指定的public属性，会递归到超类；   
> getDeclaredField是获取对象所在类中声明的指定属性，无限定符限制，但是父类继承的字段无法获取。   

> getDeclaredMethod()返回Class对象自己的所有方法，无限定符限制；  
> getMethod()是获取所有的公共方法，包括自己的、继承来的方法。

### 8、jvm
[](../java/jvm.md)

##### 说说JVM运行时数据区
> 运行时数据区，是java虚拟机定义的在程序执行期间使用的各种运行时的数据区。一般分成俩种，一种是线程共享的，一种的线程
> 私有的。其中虚拟机栈、本地方法栈、程序计数器是线程私有的，方法区、堆是线程共享的。

##### 说说JVM内存区域
> 有2类5种。2类是线程共享和线程私有。虚拟机栈、本地方法栈、程序计数器属于线程私有的，方法区、堆属于线程共享。

##### JVM的分区，各个分区的作用
> 虚拟机栈：也称栈内存。每个java方法都会创建一个栈帧。用于存储局部变量表、操作数栈、动态链接和方法出口等信息。    
> 本地方法栈：和虚拟机栈类似，只不过是Native方法服务，不是java方法。    
> 程序计数器：当前线程所执行的字节码的行号指示器，记录当前线程执行的位置。唯一不会产生OOM的区域。    
> 方法区：主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。比较少产生GC。    
> 堆：所有线程所共享的一块内存，存放实例对象(通过new创建)，经常发生GC，又称GC堆。   

##### Jvm的内存结构中，方法区有什么东西
> 虚拟机加载的类的信息、成员变量、方法、常量、静态变量和即时编译器编译后的代码等数据

##### 程序计数器为什么设计成私有
> 在多线程情况下，程序计数器用来记录自己线程的执行位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿。

##### 虚拟机栈和本地方法栈为什么设计成私有
> 虚拟机栈保存java方法的局部变量表、操作数栈等信息，为了保证线程中的局部变量不被其他线程访问到

##### 虚拟机如何解决内存分配并发问题
> jvm内存分配并发产生原因：计算机(cpu)的运算速度与它的存储和通信子系统的速度差距太大。   
> 为对象分配内存的基本方法：`指针碰撞法`、`空闲列表法`  
> 解决并发问题的方法：`CAS+失败重试`、`TLAB`--本地线程分配缓冲(Thread Local Allocation Buffer)

TLAB：
> 本地线程分配缓冲(Thread Local Allocation Buffer)，它是在Java堆中划分出来的针对每个线程的内存区域，专门在该区
> 域为该线程创建的对象分配内存。     
> 它的主要目的是在多线程并发环境下需要进行内存分配的时候，减少线程之间对于内存分配区域的竞争，加速内存分配的速度。   
> 原理：启用了TLAB之后(-XX:+UseTLAB, 默认开启)，JVM会针对每一个线程在Java堆中预留一个内存区域，在预留这个动作发生
> 的时候，需要进行加锁或者采用CAS等操作进行保护，避免多个线程预留同一个区域。一旦某个区域确定划分给某个线程，之后该线
> 程需要分配内存的时候，会优先在这片区域中申请。

##### 对象内存分配策略
> 堆分年轻代、老年代。年轻代分Eden区和Survivor区。对于新对象：优先在年轻代的Eden区，大对象直接进入老年代；经过GC后，
> 对象会进入到Survivor区；在年轻代长期存活的对象(15次GC)将进入老年代。

##### 对象实例化时的顺序
> 1、加载父类的静态成员变量和静态代码块，按代码先后顺序进行   
  2、加载子类的静态成员变量和静态代码块，按代码先后顺序进行   
  3、加载父类成员变量和方法，按代码先后顺序进行   
  4、加载父类的构造函数   
  5、加载子类成员变量和方法，按代码先后顺序进行   
  6、加载子类的构造函数  

总结就是：静态优先非静态，父类优先子类，构造方法最后，同级别按代码先后顺序。

##### Java对象如何创建的，对象创建过程
> 首先通过`new`关键字声明一个引用符号；   
> jvm对引用符号判断是否加载类该，如果没加载就加载类；    
> 为对象分配内存空间；(指针碰撞法、空闲列表法)；   
> 设置默认值(零值)；  
> 设置对象头(信息标记，比如是新生代还是老年代、锁标志等等)；   
> 执行构造方法；

##### 对象加载的过程，属性先加载还是方法先加载
> 静态的属性跟方法优先与普通属性跟方法。同是静态的或者普通，按代码先后顺序加载

##### 类加载机制的几个阶段
> 加载、验证、准备、解析、初始化、使用、卸载

##### 类加载器,双亲委派及其优势
> 类加载器负责读取java字节码文件，将class文件加载到内存。类加载器分，启动类加载器，c++实现，负责加载java的核心类。
> 扩展类加载器，负责加载ava扩展库；应用程序类加载器，负责加载用户类路径(class.path)上的指定类库。还有就是自定义类加载
> 器，自定义类加载器以ClassLoader为基类，重写其中的findClass，从指定的位置读取字节码文件。

双亲委派及其优势
> 双亲委派机制就是：收到类加载请求的时候，不会先自己去加载类，而是把请求委托给父类加载器，依次向上。最后所有的类加载请
> 求都会被传递到最顶层的启动类加载器中，只有当父类加载器中无法加载到所需的类，子类加载器才会自己去加载类。   
> 好处：避免类的重复加载、保护程序安全，防止核心API被篡改。

##### 类什么时候会被加载？类加载的过程具体生命周期是怎样的？
> 1、创建对象实例时(new)；创建子类对象实例时,父类也会被加载；用类的静态成员时(静态属性,静态方法)。   
> 生命周期：加载、验证、准备、解析、初始化、使用、卸载。

##### PathClassLoader与DexClassLoader有什么区别
> 都能加载外部环境的jar/apk文件。8.0(26)以前，DexClassLoader多一个optimizedDirectory参数，可以设置这个目录， 
> 而PathClassLoader只能使用系统默认位置。8.0(26)之后，这个参数失效，二者没有什么区别。

##### 讲讲你对垃圾回收机制的了解，老年代有什么算法？
> java GC机制能帮我们把不需要的对象占用的内存回收,保证程序高效的运行。回收机制包括标记垃圾和回收垃圾。标记算法一般
> 采用的是`引用计数法`和`根搜索法`(可达性算法)。回收算法有`标记-清除算法`、`复制算法`、`标记-压缩(整理)算法`、`分代
  收集算法`。
> 
> 老年代：因为对象存活率高，没有额外的内存空间对它进行担保。适合用`标记-清理算法`或`标记-整理算法`进行回收。

##### GC原理，有哪几种GC方式
> 原理就是标记为垃圾，然后通过一定的回收算法回收。回收算法有`标记-清除算法`、`复制算法`、`标记-压缩(整理)算法`、`分代
  收集算法`。

标记-清除算法：
> 通过标记算法，标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象

复制算法
> 首先将可用内存分为大小相等的两块，每次只使用其中的一块；当这块内存用完，将还存活的对象连续复制到另一块上面，然后把使
> 用过的那块内存空间一次清理掉。

标记-压缩(整理)算法
> 使用标记算法，标记出所有需要回收的对象；让所有的存活的对象都向一边移动，然后直接清除掉边界以外的内存。

分代收集算法
> 将堆内存划分为`年轻代`和`老年代`不同年代根据自身特性采用不同的垃圾收集算法。年轻代:老年代空间 = 1:2    
> 新生代：每次GC时都有大量的对象死亡，只有少量对象存活。考虑到复制成本低，适合采用复制算法；    
> 老年代：因为对象存活率高，没有额外的内存空间对它进行担保。因而适合采用标记-清理算法或标记-整理算法进行回收；

年轻代
> 年轻代的GC叫Minor GC。因为使用复制算法，优化后分为较大的`Eden`空间和2块较小的`Survivor`空间。每次使用Eden和一
> 块Survivor空间。Eden与2块Survivor空间比为 8:1:1。      
> 当Eden满时触发GC，把Eden存活的对象放在Survivor空间。当Eden区又满了时，把Eden区和Survivor区的存活对象放到另外
> 一块Survivor空间，循环使用。当Survivor区也快慢了，就会转移部分对象到老年区。

老年代
> 使用标记-清理或标记-整理算法，存放生命周期较长的对象。当年轻代的对象经过多次GC(15次)仍然存活或者是大对象会转移到老年代。  
> Full GC是清理整个堆空间，包括年轻代和永久代。触发Full GC的条件有：
> 1、老年代空间不足；   
> 2、调用System.gc()；   
> 3、分配很大的对象；(因为需要很大的连续空间，但又没法找到足够大的连续空间)

##### 拉圾回收的GCRoot是什么
> 是判断是否需要回收的标记算法中根搜索算法中的一个名词，参考了图论的观点，把所有的引用当成一张图，图的第一个节点(对象)就是
> GC_Root。根据每个对象的引用是否能到达GC-Root，如果不能就表示该对象是垃圾。能当成GC-Root的对象有：
> -虚拟机栈中的对象引用；   
> -方法区中的类静态属性的对象引用；   
> -运行时常量池中的对象引用；   
> -本地方法栈的对象引用；   
> -被启动类加载器加载的类和创建的对象

##### 对象的访问定位有哪几种
> 直接指针访问、句柄访问(如果是句柄访问堆会划分一块内存作为句柄池，引用中存储的就是对象的句柄地址)。HotSpot使用是直接指针
> 访问对象。

##### 例如启动20s，如何知道gc了多少次，花费了多少时间。可以针对性做哪些优化
> 查看次数：jvmti工具、leakcanary做法

