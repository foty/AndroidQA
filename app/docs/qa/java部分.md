
### 1、基础知识

##### 说说  ==、equals 和 hashcode
简单说说，无非是什么，有什么用，有什么区别。参考回答：
> 它们都是用来判断对象是否相等。
> 不同点：`双等号(==)`对于基本数据类型，只要它们的值相同，结果就是true，否则false。对于非基本数据类型对象，是判断
> 是否为同一个内存地址，同一个引用；`equals`是Object中的方法，并且Object中equals默认使用==来判断，判断内容是否相
> 同，也就是值比较，==是引用比较；  
> equals与hashcode也是比较2个对象内容是否相等，并且都是Object中的方法。如果2个对象相等，hashcode一定相等，equals
> 也是返回true；如果只有equals相等，2个对象也是相等，它们的hashCode()也一定相等；如果只有hashcode相等，2个对象不
> 一定相等，equal也不一定相等。equal对应是准确性，hashcode对应是效率。

##### 为什么有了equals(hashcode)还要hashcode(equals)。
> 因为重写equal比较全面、复杂，效率就变低，而利用hashCode进行对比，只要生成一个hash值进行比较就可以，效率比较高。 
> 
> 因为hashCode并不完全可靠，有时候不同的对象他们生成的hashcode也会一样。(java中的hash函数返回的是int类型，对于
> hashcode的计算也是有限的，数据量大就有可能出现相同的hash值)

##### equals 和 hashcode如何协调比较。
> 当需要对比的时候，首先用hashCode去对比，如果hashCode不一样，则表示这两个对象肯定不相等，就不必再用equal去比较；
> 如果hashCode()相同，再对比他们的equal()。如果equal()也相同，则表示这两个对象是相同的。这样既能提高效率也能
> 保证准确性。

##### equals、hashcode为什么必须重写,只重写一个会怎样。
只重写一个无法保证准确性，无法满足所有需求，还会引发其他错误。
> 只重写equal，那么2个对象比较的就是hashcode，这个值是由内存地址转化而来，不同对象一定不同。这会导致创建的2个对象所
> 有属性都相同，但是因为hashcode没有重写，程序识别为2个不同的对象。即是equals相等了，hashcode也不等，违反hashcode
> 规则。  
> 只重写hashcode，那么比较的其实是对象的地址值(equals默认==实现)，不同对象也一定不同，甚至可以说2个对象永远不会相
> 等；

##### HashMap和HashSet为什么必须同时重写hashcode和equals。
> 一是hashcode和equals只重写其中一个都无法保证HashMap与HashSet内元素的准确性，就是无法判断2个对象是否相等；   
> 二会导致hash容器无法正常工作。(hash表是以key-value保存数据，key就是根据对象hashcode计算而来：
> 计算key下标的方式：(n - 1) & hash，n是数组长度。只重写equals会导致hashcode出现相同，导致无法保证key的唯一性)；
> 只重写hashcode会导致2个不同对象会被挂载到同一个key上，后挂载的会替换前挂载的，导致使用key获取的不是同一个对象。)

##### HashCode的作用
> 对象区别于其他对象的标识,hashcode是当前对象的地址值计算转化来的。

##### Switch能否用string做参数
> Java 1.7之前只能支持byte、short、int、char或其封装类及enum类型，1.7及以上才支持string，boolean类型也是不支持

##### java基本数据类型有哪些，int，long占几个字节
> 4类8种。
> 整数类(byte[1个字节，-128~127]、short[2个字节，-32768~32767]、int[4个字节，-2的31次方~2的31次方-1，约21亿]、
> long[8个字节])；   
> 浮点类(float[4个字节]、double[8个字节])、   
> 字符类(char[2个字节])、  
> 布尔类(boolean[占1位]);除此外都是引用数剧类型。  

##### Java面向对象的三个特征与含义。
> 封装：把客观事物封装成类或对象，隐藏对象的属性和实现细节，对外提供接口访问；   
> 继承：让某个类型的对象获得另一个类型的对象的属性和方法。继承导致类之间有分等级层次，子类可以继承父类的特征和行为，使
> 得子类具有父类相同的属性和行为；   
> 多态：同一个行为，不同的子类对象具有不同的表现形式。只有在运行的时候才知道引用指向的是哪个类的实例对象，以及引用调
> 用的方法指向的是哪个类中实现的方法。比如`重载`跟`重写(覆盖)`，父类引用指向子类实例等等。

##### java有什么特性，继承有什么用处，多态有什么用处。
> 封装：对内部数据提供了不同级别的保护，代码重用；
> 继承：扩展已存在的类或对象，代码重用；
> 多态：增加类或对象使用的灵活性和扩展性；

##### java为什么能做到多态
> 只有在运行的时候才知道引用指向的是哪个类的实例对象，以及引用调用的方法指向的是哪个类中实现的方法(运行时类型判定)。
> 因为    
> 1、类之间的继承关系。  
> 2、方法的重载跟重写。   
如果子类改写了父类的方法，那么子类和父类的同名方法共享一个方法表项，都被认作是父类的方法。在调用子类方法时，通过解析子
类实例方法获取对应方法表中的偏移量，通过偏移量找到实际的方法。

##### Override和Overload的含义去区别。
> Override：重写/覆盖。方法名、参数、返回值与父类完全相同。存在与父类子类之间；   
> overload：重载。方法参数的类型、个数、顺序至少有一个不相同。存在同个类的方法与方法之间；

##### String s = new String("xx")创建了几个对象
> 1个或者2个。如果常量池存在"xx",就是创建了1个，如果常量池不存在"xx",就是2个(引用对象s不算)。[]

##### new String("a") + new String("b")有几个对象
> 6个。分别是 new StringBuilder(拼接的默认使用StringBuilder拼接)，常量池a，堆内存a(new String(a))，常量池b，
> 堆内存b，堆内存ab。[注意，常量池内没有"ab"]

##### String 的intern()会发生什么
> jdk1.6，如果常量池存在该对象，不会再次放入池，返回`常量池对象地址`；如果不存在，复制一份`对象`放入常量池。返
> 回`常量池对象`。(相当于有2个对象，2个对象不是同一个)。   
> jdk1.7及以上，如果常量池存在该对象，不会再次放入池，返回`常量池对象地址`；如果不存在，复制`对象引用`放入常量池，返
> 回`常量池的引用`。(常量池的是原对象的引用地址，都是同一个对象)

##### String是最基本的数据类型吗
> 不是。

##### 是否可以继承String类
> 不能，String是final修饰的，实现细节不允许改变。

##### 为什么final不能被继承
> 在java中，final关键字是“这是无法改变的”或者“终态的”含义。规定无法被它修饰的类无法继承，可能是出于设计或者效率。

##### String、StringBuffer与StringBuilder的区别。
都可以用来表示字符串。
> String是固定长度字符串，即是有拼接操作也是返回创建新的字符串对象；而StringBuffer与StringBuilder是可变字符串，
> 可以在原对象基础上拼接，对象不会改变(原因是它们内部使用char数组拼接处理)；所以String做拼接效率很低。String适用于
> 少量的字符串操作，StringBuffer与StringBuilder适用于大量字符串操作。    
> StringBuilder是线程不安全的，单线程环境表现突出。StringBuffer是线程安全的，多线程环境下表现突出。(内部的char数
> 组基础容量是16，每次扩容为增加原来一倍+2)

##### &和&&的区别？
> & 属于位运算，按位与，&&属于逻辑运算，逻辑与。   
> &&有短路功能，即第一个表达式为false时，整个结果就是false，不再判断第二个表达式；&没有短路功能

##### 值传递与引用传递？java是引用传递还是值传递
值传递和引用传递的区别并不是传递的内容，而是实参到底有没有被复制一份给形参。
> 值传递：复制一份变量传递给其他变量，在方法中修改并不会改变原始变量的值；引用传递：直接传递对象的地址，修改会改变对象
> 本身的值。    
> java是值传递，没有引用传递。对于基本数据类型，是传递对象量值的副本；对于引用类型，是该对象在内存中的地址值的副本。

##### int和Integer区别
> Integer是int的包装类；int是基本数据类型;   
> Integer变量必须实例化后才可以使用，而int变量则不需要;  
> Integer的默认值是null，而int的默认值为0.

##### char类型变量中能不能存贮一个中文汉字
> 可以。char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含汉字。如果某个汉字没有被包含在unicode编码
> 字符集中，那么这个char型变量就不能存储这个汉字。unicode编码占用两个字节；char类型的变量也是占用两个字节。

##### try catch finally，try里有return，finally还执行么
> 会执行。但是finally无法改变返回值。因为在执行的过程中, 如果try执行到return,会先将结果保存在一个临时变量中,等
> 到finally执行完毕之后再将保存的值取出返回。

##### java中静态方法，能不能被子类重写？编译会报错么
> 不能重写。静态方法只与类有关系，跟实例对象没有关系。重写是为了多态，静态方法在加载时就绑定了类，不存在父类引用指向子
> 类实例，也就不存在多态。但是子类可以声明与父类相同参数，同名的静态方法，但是这个类是绑定子类的，不能加重写注解。

##### 在一个静态方法内调用一个非静态成员为什么是非法的？
> 静态方法是跟随类的，随类的加载而加载；而非静态方法属性是属于对象的，对象是在类加载完后创建生成的。对象没有生成，非静
> 态成员当然也不存在。只依赖于类而不依赖于对象的静态方法自然不能调用一个不存在的方法，也不知道哪个对象，哪个成语变量。

##### 静态类与非静态类的区别。
> java中，静态类只能是内部类，因为外部类无法用static修饰。
> 看下面内部类特点。

##### 匿名内部类的特点
> 匿名内部类可以访问外部内的所有成员，外部类不能访问内部类的属性、方法   
> 匿名内部类不能访问外部类未加final修饰的变量(jdk1.8即使没有用final修饰也可以访问)   
> 匿名内部类中不能定义静态属性、方法   
> 内部类的隐藏属性this、super都是指向内部类自己。

##### 匿名内部类能不能访问外部类的私有方法(属性)？为什么
> 可以。内部类总有一个隐式引用指向外部类，在编译过程中，编译器会为外部类的私有属性生成静态方法。

##### 匿名内部类编译后也是独立的外部类，它为何能访问外部类的私有方法？如果能访问，怎么做到的？
> 内部类总有一个隐式引用指向外部类，在编译过程中，编译器会为外部类的私有属性生成相应的静态方法。

##### foreach与正常for循环效率对比。
> foreach效率更高。foreach只能用于遍历，不能更改循环目标，遍历速度快，执行效率高。for循环可以用于任何形式的重复行
> 为，在循环体中可以进行任何操作，所以遍历速度慢，执行效率低。

##### 装箱和拆箱的原理
> 装箱：自动将基本数据类型转换为包装器类型，调用`valueOf()`完成装箱；    
> 拆箱：自动将包装器类型转换为基本数据类型，调用了`***Value()`完成拆箱；   

### 2、数据结构、集合容器

##### ArrayList、LinkedList、Vector的区别
> ArrayList：使用可变数组实现，可以添加任何元素，包括null；  
> Vector：几乎与ArrayList一样，但是Vector是线程安全的；  
> LinkedList：双向链表实现，可以添加任何元素，包括null；

##### Map、Set、List、Queue、Stack 的特点与用法。
> Map：以key-value键值对结构存储元素；key唯一，value可以重复；元素可以无序(hashMap)，也可以有序(LinkedHashMap)   
> List：保存元素有序；允许重复元素，可以通过下标访问元素；   
> Set：保存元素元素唯一，可以排序(treeSet)；  
> Queue：先进先出；
> Stack：先进后出；

##### ArrayList扩容机制？
> 初始容量为10，扩容因子为1.5，即扩容后容量是原容量的1.5倍，计算方式为`new = old + (old >> 1)`。当数组的长度小
> 于最小需要的容量(当前元素容量+待添加的元素数量)就扩容。

##### 为什么ArrayList扩容因子是1.5
> 首先扩容容量不能太小，防止频繁扩容，数组频繁复制；第二，扩容容量不能太大，需要充分利用空间，避免浪费过多空间；还有就是
> 计算尽量高效，使用位运算的计算效率是比较高的。

##### 链表的查找的时间复杂度是多少
> O(n)，因为链表始终需要按照顺序一个一个查找对比。

##### TreeMap、HashMap、LinkedHashMap的区别。
> HashMap：根据key的HashCode值存储数据，有很快的访问速度，取出的数据的顺序是随机的
> LinkedHashMap：内部有双向链表，存取元素时有序的(保存顺序与取出顺序一样)；
> TreeMap：基于红黑树实现，具有排序功能,默认是自然排序(升序)

##### 讲讲LinkedHashMap的数据结构，实现按顺序存取的原理。
> 继承HashMap，实现Map接口。内部维护代表链表头尾节点的两个对象，并且重写HashMap创建节点的方法，在调用父类put()添加
> 元素创建节点时，控制头尾结点，完成链表元素添加。当删除元素时也是先删除hash表上的元素，然后再通过重写方法移除节点。

##### HashMap和HashTable的区别。
--  |  HashMap  |   HashTable
:--- | :--- | :----
多线程问题 | 线程不安全、效率高 | 线程安全、效率低
底层结构 |  数组+链表 + 红黑树(jdk1.8后) | 数组+链表
扩容方面 | 初始容量大小为16，扩容后变为原来的2倍 | 初始容量大小为11，扩容后会变为2n+1
继承关系 | AbstractMap | Dictionary(被废弃)

##### HashTable为何废弃
> 线程安全形成效率低下；HashTable继承的父类也是被废弃了。

##### ConcurrentHashMap
产生原因、区分jdk7跟jdk8的区别
> 因为HashMap是非线程安全的，在并发情况下存在很大的隐患(多线程扩容时，链表可能会出现死循环)；HashTable虽然是线程安
> 全的，但是因为它所有的get/put都添加了synchronized，导致性能非常差。于是ConcurrentHashMap便出现了。    

jdk1.7版本：
> 底层数据结构是数组和链表。但是与HashMap不同的是引入了一个`Segment`的东西。Segment本身就像是一个HashMap，还继承
> ReentrantLock。HashMap的底层结构是个Entry数组，里面的元素是一个链表的表头，而ConcurrentHashMap的底层结构是
> Segment数组，每个Segment包含一个Entry数组，每个元素都是一个链表的表头。像个二级HashMap。
> 
> 结构好处：使用分段锁技术，实现真正的并发。[多线程环境下，不同Segment之间读写互不影响；同一个Segment下的读取、一读
> 一写也能并发执行，写入并发时需要获取锁，否则阻塞。]坏处是查找过程要比普通的HashMap要长。      
> 
> 查找数据：需要进过2次查找，第一次定位到Segment，第二次定位到元素所在Segment内部数组元素，也就是对应链表的表头。  
> 
> 统计元素size：首先遍历所有的Segment，统计元素数量以及发生修改次数。当修改总数与上次统计一样时，说明没有修改，当前
> 统计的数量就是map内的总数量，统计结束；当不一样时，重新统计，统计计数器+1。当统计次数到一定数量(3次)时，对每个
> Segment加锁，再次统计，最后返回总数(加锁后无法再修改，所以前后修改次数是相同的)。     
> 原因：上来就直接锁住所有Segment，统计完再解锁。这样做会影响到Map的其他读写操作，不利于并行。

jdk1.8：
> 底层数据结构：为了提高并发性，放弃分段锁的方案；采用数组+链表+红黑树的数据结构，与HashMap一样。采用CAS+
> synchronized保证线程安全

##### HashMap和ConcurrentHashMap的区别
> 最大区别就是HashMap线程不安全、ConcurrentHashMap线程安全。

##### 说说HashMap的原理
> HashMap是基于数组+链表结构设计的。数组中的每个元素都是一条链表的表头。数组默认长度为16。添加元素时，根据key的hash
> 值与数组长度-1,做与运算，得到元素在数组中的位置。如果数组对应索引存在元素并且它们的hash值不一样，就将新元素添加到后
> 面(尾插法，jdk1.7是头插法)成为该链表的一个新节点。jdk1.8后，引入红黑树，当hash数组的容量大于64且链表长度大于8时，
> 链表转红黑树；当长度小于6的时，红黑树转链表。

##### HashMap中hash函数怎么实现的，还有哪些hash函数的实现方式
> 首先获取到key的hashcode值， 然后让hashcode值的高16位和低16位进行异或操作。目的是为了降低哈希碰撞的概率。

##### HashMap中get()、put()如何实现的
put：
> 1、计算key的hash值；   
> 2、计算key在数组中的索引(hash&(arr.length-1)；   
> 3、如果当前索引对应的数组元素为null，直接在该索引上，充当链表头几点；如果不为null，比较key的hash值或者equals，
> 有一个不同时将新元素插入到链表成为新节点；如果都hash值跟equals都相等，替换value。

get:
> 1、计算key的hash值；   
> 2、计算key在数组中的索引(hash&(arr.length-1)；    
> 3、key的hash值判断，如果是链表头节点则返回头结点；如果不是，判断表头节点是否属于红黑树。如果是，遍历红黑树查找
> 到目标，否则遍历链表找到指定元素。

##### hashmap扩容是怎么做的，怎么处理hash冲突
> 当元素数量超过阈值时便会触发扩容。每次扩容的容量都是之前容量的2倍。[阈值 = 数组容量 * 负载因子]。默认初始容量为16，
> 负载因子为0.75。

解决hash冲突(Hashmap如何解决散列碰撞)：
> 1、链式地址法。在冲突的位置拉一个链表，把冲突的元素放进去。(数组+链表结构)
> 2、扰动函数。(hash函数[哈希值的高16位^哈希值的低16位])。(从哈希值入手，尽可能保证哈希值不一样)
> 3、引入红黑树。(优化Hash表链表过长导致时间复杂度增加)
> 4、再Hash法(未使用)。利用多个hash函数，遇到冲突时就使用其他hash函数计算，直到不冲突。(缺点：计算时长增加)

##### 当两个对象的hashCode相等时会怎样
> 发生哈希冲突，若key值内容相同则替换旧的value，否则添加到链表后面，当链表长度超过阈值8，并且数组长度大于64就转为
> 红黑树存储。

##### hashmap扩容会有什么问题吗
> 链表可能会出现死循环。原因：多线程环境 + 链表头插法(jdk1.7为头插法，1.8后变成尾插法)
> <https://www.cnblogs.com/zhuoqingsen/p/8577646.html>

##### HashMap查找的时间复杂度是多少？
> 找表头元素是O(1)，因为数组的索引指定查找；链表时O(n)，红黑树时O(logN)

##### 为什么HashMap初始大小是2的次幂，对扩容有没有影响
> 能够满足位运算提高效率。(hash值很大，数组长度相对较小，需要取余才能作为数组下标，而位运算代替取余效率会很高)；     
> 打乱key的hash值[右移+异或]后在进行[&运算]能得到更平均的数组索引。(尽可能的将集合元素分配到数组的不同位置上，
> 减少哈希碰撞)。

> 扩容时扩大为原来长度的2倍，长度始终保持是2的n次幂。

##### HashMap的数据结构,如何保证快速查找。
> jdk1.7 数组+链表；jdk1.8 数组+链表+红黑树。当链表节点数量少时，查询时间较快；当链表节点多时，链表转红黑树。当红
> 黑树节点又变少时，红黑树转链表。

##### Hashmap底层为什么是线程不安全的
> 因为它的put方法无法保证原子性以及可见性。导致在多线程环境下扩容时会发生死循环(链表成环)，djk1.8会数据覆盖。

##### 解决hash冲突的时候，为什么用红黑树
> 当HashMap的key冲突过多时，会导致链表过长，此时链表的查询效率很差，引入红黑树优化查询效率，空间换时间。

##### 红黑树的效率高，为什么一开始不用红黑树存储
> 因为红黑树的节点比链表节点大(2倍)，占用空间更大，而且链表比较短的时候查询也足够快，没必要直接使用红黑树的结构。

##### 为什么阀值是8才转为红黑树
> 8其实是一个预估值。和hashcode碰撞次数的泊松分布有关，产生8次碰撞的几率为0.00000006，比千万分之一还小的概率。正
> 常情况下不会存储这么多数据，hashCode分布比较良好，数据分布也比较均匀，很少出现链表很长的情况。出于对时间和空间平衡
> 的选择结果。

##### 为什么退化为链表的阈值是6
> 如果退化阈值也设置为8，那么可能会出现链表和红黑树的不停相互转换，浪费资源；中间留下个差值7可以防止链表和树之间的
> 频繁转换。

##### 二分搜索树的特性和原理
特性
> 每个节点的值都小于其右子树的所有节点的值；   
> 每个节点的值都大于其左子树的所有节点的值；     
> 每一棵子树也是二分搜索树；

##### 堆的实现，最大堆，最小堆，优先队列原理
> 堆的实现：使用优先队列(java自带的API PriorityQueue)、使用数组

优先队列
> 优先队列是一种特殊的队列，为元素赋予优先级，具有最高优先级的元素成为队列头部，一般分最大优先队列、最小优先队列。通过
> 下沉或上浮操作，保存队列头部始终最大或最小。

##### Comparable和Comparator的区别
> 所在包类不一样：comparable在`java.lang`包下，comparator在`java.util`包下   
> 实现重写方法不一样；实现comparable要重写compareTo(T o)方法；实现comparator要重写compare(T o1,T o2)方法；   
> Comparable是排序接口，实现它的类意味着自己本身具有比较功能，将自己与另外一个对象比较排序；Comparator是比较接口，
> 实现它的类能够将两个不同对象比较，自己本身无法比较排序。Comparable相当于内部比较器，而Comparator相当于外部比较器

##### LRU算法实现
> Least Recently Used的缩写，即最近最少使用法则。   
> 实现：使用双向链表+同步机制(比如Hashtable)或者LinkedHashMap。最近命中或新添加的放在头部，链表尾部的将会在容量
> 满时被移除。

##### ArrayMap和SparseArray
> SparseArray：使用2个数组(key数组+value数组)，key指定为int类型，不需要hash值，基于二分查找存取数据，提高查找效
> 率。它的删除也不是真正移除元素，而是设置一个删除标志。存储基本类型数据，避免数据的装箱拆箱，某些情况下性能更好。对
> 比HashMap，以时间换空间。它的出现是为了节省内存以及提高效率。不需要创建节点消耗内存。但也因为需要移动数组会消耗性
> 能，所以只适用数据量很小的情况。
> 
> ArrayMap：类似ArrayMap，使用2个数组，mHashes和mArray。mHashes记录所有key的hashcode值；mArray记录所有
> key-value键值对，也都是基于二分查找存取数据。对比HashMap，同样不需要创建节点，节约内存，数据量小时查找效率更高，
> 不是和数据量大的环境。   
> > ArrayMap解决hash冲突：向后追加。比如在位置i发生碰撞，则将i后的数据往后移，在i+1位置插入数据。mHash中相同的
> hashcode都是连接在一起的。


### 3、泛型 
[文档](../java/泛型.md)

##### 泛型常用特点，泛型有什么优点
> 性能高。存储值类型或转换为值类型时不需要装箱和拆箱；  
> 代码简洁方便。内部的转换都是自动和隐式的，省略强制转换代码；
> 类型安全。编码时限定了类型，只要编译时期没有警告，运行时就不会抛出类型转换异常，把运行时的问题提前到编译时期。

##### List<String>能否转为List<Object>。
> 不行。因为泛型存在类型擦除，在编译后都会变成List，无法区分。还有String是Object的子类型，但是List<String>不是
> List<Object>的子类型，二者无法直接转换。

##### 泛型是怎么解析的，比如在retrofit中的泛型是怎么解析的
> Gson[GsonConverterFactory]

##### 泛型为什么要擦除？泛型的pecs原则
> 为了向后兼容，让使用泛型的代码可以和没有使用泛型的代码随意互用。

PECS：
> 要从泛型类取数据时，用extends;   
> 要往泛型类写数据时，用super;    
> 既要取又要写，就不用通配符(即extends与super都不用)。  

##### 为何会有协变和逆变
> java泛型是不变的。但是为了让泛型能变的像普通类一样具有继承关系。实现逆变与协变，就是利用通配符?。

##### 通配符
泛型的通配符是用于`解决泛型之间引用传递问题的特殊语法`, 在逻辑上还原了泛型类传入数据类型的参数父类子类的继承关系，同时
也可以按照需求设定通配符的上限与下限。
> 无边界通配符，写作`?`，表示可以是任何类型；    
> 固定上边界通配符，写作`? extend T`，表示必须是T或者T的子类类型；   
> 固定下边界通配符，写作 `? super T`，表示必须是T或者T的超类(父类)   


### 4、线程、多线程、线程池、同步
[文档](../java/并发(锁).md)

##### 实现多线程的两种方法。
> 继承Thread类或实现Runnable接口。

##### 创建线程的几种方式
> 继承Thread类、实现Runnable接口、创建Callable接口的实现类、使用线程池。

##### 线程的几种状态
> 新建、就绪、运行、死亡、堵塞。

##### 怎么中止一个线程，Thread.Interrupt一定有效吗
> 1、设置flag，让run()提前结束。   
> 2、使用stop()方法强行终止线程。   
> 3、使用interrupt()方法.

interrupt()一定有效吗
> 通过调用interrupt()方法是将isInterrupt标志位变成true，当run方法知道到该标志位时就会抛出异常达到终止线程的目的。理
> 论上是有效的。

##### wait()和sleep()的区别
> sleep不释放锁，wait释放锁;   
> sleep是Thread的方法，wait是Object的方法;

##### interrupt()、interrupted()、isInterrupted() 区别
> interrupt()：改变中断状态，它不会中断一个正在运行的线程。返回值时void。   
> interrupted()：测试是否中断，返回当前线程的中断标志位(boolean值)，并设置中断标志位为false；   
> isInterrupted()：测试是否中断，返回线程对象的中断标志位。

##### start()、run()的区别
> start()是启动一个线程，run()只是调用一个方法。 
> run()可以重复调用，start()不可以。   
> start()实现了多线程，run()没有实现多线程。

##### 多线程存在哪些问题
> [原子性问题]：A给B转账100，对应的操作就是A-100，B+100。如果没有原子性，只是单方面加或减,必然会产生问题。     
> [可见性问题]：多线程访问同一个变量时，一方面对变量修改，其他线程应该立即看到修改，如果不及时也必然会产生问题。   
> [有序性问题]：主要是jvm为了提高效率，会改变程序语句的执行顺序。比如双重检查创建单例对象。程序顺序是先分配内存、然后初
> 始化、最后将内存地址给单例对象。然而经过jvm的优化后，顺序变成了先内存地址给单例再初始化。造成的结果就是单例对象没有
> 初始化，引发空指针异常。    
> [死锁]。

##### 并发和并行区别
> 并行： 指两个或多个事件在同一时刻发生；   
> 并发： 指在同一时刻，只能有一个事件执行，但多个进程原因被快速轮换执行，使得宏观上具有多个事件同时执行的效果。   
> 举个例子：并发是一个人同时吃三个馒头，而并行是三个人同时吃三个馒头。

##### 线程池核心参数  
> `corePoolSize`核心线程数量，`maxPoolSize`最大线程数量，`keepAliveTime`线程存活时间，`unit`存活时间单位，
> `workQueue`工作队列，`threadFactory`执行器创建新线程时使用的工厂，`handler`拒绝策略。

##### 为什么用线程池
> 节约资源。重用线程，减少新建-销毁线程的开销，还能有效控制线程并发数量，避免线程间抢占系统资源而导致阻塞；   
> 能够统一管理；

##### 线程池了解多少？拒绝策略有几种,为什么有newSingleThread
> 4种拒绝策略。简述为：拒绝无处理、拒绝并抛异常、直接执行、抛弃最旧的任务执行新任务。  

为什么有newSingleThread(newSingleThreadExecutor)
> 这是一个单一线程池。corePoolSize为1，maximumPoolSize为1，keepAliveTime为0，阻塞队列使用的是
> LinkedBlockingQueue。该线程池的特点是保证了所有任务的执行顺序按照提交顺序来执行。

##### ThreadLocal的设计理念与作用。
> 理念：在多线程并发执行过程中，为了保证多个线程对变量的安全访问。   
> 作用：使变量在每个线程中都有独立值，不会出现一个线程读取变量时被另一个线程修改的现象。   

##### 如何配置线程池的？核心线程数一般是怎么配置的
> 考虑CPU核心数，再看是CPU密级型任务还是IO密级型任务。如果是CUP密集型，核心线程数 = CPU核数即可。也可以设置为CPU核
> 数+1，达到最大利用率。如果是IO密集型任务，则跟CPU计算速度和IO读写速度相关，可以分别计算2者的一个比值关系乘以cpu核数。

##### 如何让两个线程循环交替打印
> 常规方法，[while阻塞+flag]。声明一个flag，2条线程，一条线程flag为true时打印，一条为false时打印。中间使用while阻
> 塞，每次打印完将flag设置为对方的flag打印状态。

例子看[Bb.testNormal()]

##### 三个线程依次打印，有哪些方式
> [flag+while阻塞+ReentrantLock+Condition]。flag控制打印线程顺序，ReentrantLock控制线程加锁与释放锁，while，
> Condition控制阻塞与唤醒。每当一条线程打印完，唤醒下一条需要打印的线程并且释放锁。

例子看[Bb.print3()]

##### 谈谈线程死锁，如何有效的避免线程死锁？
> 死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象。产生死锁的必要条件有：
> 1、互斥条件(某个资源被一条线程使用时，其他线程无法使用)；   
> 2、不可剥夺(线程获取到的资源在自己使用完之前无法被其他线程占用，只能自己使用完后自己释放)；   
> 3、请求并且持有条件(一个线程持有了一个资源，又去请求新资源，但新资源被已被占用，自己陷入阻塞又无法释放持有资源)；   
> 4、环路等待条件(发生死锁时，必然存在一个等待资源线程--占用资源线程的环形链)

避免死锁
> 破坏死锁的4个必要条件即可避免死锁。第一、第二非程序本身能够控制，所以只能破坏第三、第四个条件之一。比如：  
> 保证资源使用的有序性能破坏请求并持有条件，设置等待时间、定时锁可以避免一直阻塞无法释放破坏环路等待条件。

##### 如何实现多线程中的同步
> synchronized同步方法、同步代码块、使用Volatile、使用重入锁(ReentrantLock)

##### 何为阻塞队列
> 阻塞队列是一个支持两个附加操作的队列。这两个附加操作是：在队列为空时，获取元素的线程会等待队列变为非空;当队列满时，
> 存储元素的线程会等待队列可用。

##### 为什么会有线程安全？如何保证线程安全
> 因为系统调度线程具有随机性，会导致数据操作的原子性、可见性、有序性无法保证而产生bug，这时线程就是不是安全的。保证
> 原子性、可见性、有序性的就是线程安全。   

如何保证线程安全
> 使用synchronized、Lock锁(如[ReentrantLock])保证线程同步；使用volatile保证可见性，禁止指令重排(有序性)


### 5、锁
[资料](../java/并发(锁).md)

##### 锁之间的区别，同步锁举例
> 同步锁：synchronized。

##### 锁的分类，锁的几种状态
> 可重入锁：线程获取到锁后可以重复获取锁并且不会导致死锁。在java中有：ReentrantLock、synchronized。
> 公平锁：多个线程之间通过申请顺序来获得锁权限
> 非公平锁：非公平锁则是指线程之间获得锁的顺序不是按照申请顺序
> 互斥锁：线程获取到锁后，其他线程再次获取锁会失败，然后释放cpu，进入阻塞状态(与自旋锁相反)
> 自旋锁：指尝试获取锁的线程后不会立即阻塞，而是通过循环的方式去尝试获取锁。

锁有四种状态，随着锁的竞争，锁的状态只有升级，没有降级。偏向锁->轻量级锁->重量级锁。
> 无锁    
> 偏向锁：特点是加锁和解锁不需要额外的消耗。但是如果有多个线程竞争，会带来额外的锁撤销消耗。适用于单线程环境。    
> 轻量级锁：特点竞争的线程不会阻塞，提高响应速度。但始终无法竞争到的线程会进入自旋消耗cpu。适用追求响应时间，执行速度
快的环境。     
> 重量级锁：特点是线程竞争不会自旋，不会消耗cpu。但线程会进入阻塞状态，响应慢。  

##### 如何避免死锁
> 破坏产生死锁的4个必要条件。`互斥`，`不可剥夺`，`请求并持有`，`环路等待`。实际当中，第一、第二点无法或很难实现，所以
> 可以针对第3、4条件处理。比如保证请求资源的有序性，可以避免请求并持有条件；设置锁定时间，定时释放可以避免环路等待。

##### 平常有用到什么锁，synchronized底层原理是什么
> 是对jmv层面的monitor对象加锁解锁实现同步。方法级别的同步是根据方法表中的同步标志判断是否事同步方法。如果是则会先去获
> 取monitor对象，执行完方法释放monitor对象；代码级别的同步是根据monitor-enter和monitor-exit指令完成。执行
> monitor-enter获取monitor对象，执行monitor-exit，释放monitor对象。

##### Lock原理
> 状态值 + AQS(双端阻塞队列) + CAS。多数使用它的实现类[ReentrantLock]。    
> 状态值记录线程是否获得锁。没有获得锁的线程构建成节点添加到同步队列，设置成尾结点，通过底层方法进入阻塞状态。设置尾结点
> 是需要保证线程安全的所以需要通过CAS完成。当上一个获得锁的线程释放锁后，队列唤醒头结点的线程，尝试获取锁。

##### synchronized和Lock区别
> synchronized是一个关键字，Lock是一个接口；   
> synchronized能自动释放锁，Lock不会；   
> synchronized只能等待锁释放，Lock可以中断等待；   
> synchronized是独占锁，Lock可以实现为独占锁，也可以是共享锁；   
> synchronized是隐式锁(不需要手动加锁释放锁)，Lock是显示锁(需要手动加锁释放锁)。

##### synchronized是公平锁还是非公平锁,ReentrantLock是公平锁吗？是怎么实现的。
> synchronized是非公平锁，因为需要竞争，不是按照顺序。ReentrantLock可以实现为公平锁，也可以实现为非公平锁。通过AQS
> 实现锁资源竞争。队列是一个FIFO的双向链表，能满足有序竞争锁资源。

##### JMM可见性，原子性，有序性，synchronized可以保证什么
> 可以保证可见性，原子性，有序性(多线程下顺序执行)

##### volatile了解吗
> volatile是Java虚拟机提供的轻量级的同步机制，它的特性有：能保证可见性、但不保证原子性、禁止指令重排。

##### volatile如何保证可见性、禁止指令重排的原理是什么
> 可见性原理：jvm将.class文件编译成机器码后，使用volatile修饰的变量会在指令添加一个`Lock`前缀。有Lock前缀指令会导
> 致当前处理器缓存数据会写入到系统内存；而处理器把缓存写入到内存会让其他处理器的缓存失效，当发现这个变量的缓存失效时，会
> 从内存中重新读取。保证这个变量对于所有线程始终是最新值。
> 
> 禁止指令重排的原理：在编译成字节码时，会在volatile变量指令前后插入内存屏障，禁止处理器重排序。

##### volatile字段有什么用途？
> 能保证可见性、但不保证原子性、禁止指令重排(插入内存屏障)。

内存屏障类型(`Load`-代表读，`Store`代表写)

类型名称  |   指令  | 说明
:----  |   :----- | :----
LoadLoad | Load1;_LoadLoad_;Load2 | 确保`读取Load1操作`优先于`读取Load2操作`(以及Load2后面的)
LoadStore | Load1;_LoadStore_;Store2 | 确保`读取Load1操作`优先于`Store2写入到内存操作`(以及Store2后面的)
StoreStore | Store1;_StoreStore_;Store2 | 确保`Store1操作`优先于`Store2操作`写入到内存(以及Store2后面的)
StoreLoad | Store1;_LoadLoad_;Load2 | 确保`Store1写入到内存操作`优先于`读取Load2操作`(以及Load2后面的)

volatile的内存屏障策略插入策略会在这4个位置插入内存屏障，实现禁止指令重排。

##### synchronized和volatile的区别？为何不用volatile替代synchronized？
> volatile只能使用在变量上，synchronized可以使用在变量和方法与类级别上；   
> volatile不会造成线程阻塞，synchronized可能会造成线程阻塞；   
> volatile只能保证可见性，无法保证原子性，synchronized可以原子性和可见性；   
> volatile能禁止指令重排，synchronized不能禁止指令重排；   
> 

为何不用volatile替代synchronized
> volatile无法保证原子性，所以它无法替换synchronized。

有了synchronized为什么还要volatile
> synchronize不能保证单个线程内部指令的顺序，也就是指令重排，任然有线程安全问题。比如双重检查单例创建问题，为什么还使
> 用volatile。第二点就是还会阻塞，内部的隐式锁增加性能消耗。

##### AQS了解吗？
> `AbstractQueuedSynchronized`的缩写，又称抽象队列式同步器。作用是给java一系列锁以及同步器或者同步对象的底层提供
> 了实现的框架，一种规范。提供解决同步问题的基础框架。 

AQS实现：
> 通过CLH同步队列完成同步状态的管理，如果线程获取同步状态(锁)失败时，AQS会将当前线程构造成一个节点加入
> 到CLH同步队列尾部，同时会阻塞当前线程。当同步状态(锁)释放时，会把首节点唤醒(公平锁)，使其再次尝试获取同步状态。
>
> CLH(Craig, Landin ,and Hagersten)：--同步(等待)队列，是一个FIFO双向队列，拥有pre前驱节点、next后驱节点。   
> FIFO(first-in-first-out)：--先进先出；   

##### AtomicInteger如何保证原子操作
> CAS + Volatile。  
> UnSafe的作用：获取对象偏移量，拥有直接操作对象内存地址的能力。直接操作内存效率更高。

##### CAS如何保证原子操作,CAS原理
> CAS其实就是Compare And Swap的一个缩写。即把当前值与预期的值进行一个比较，如果一样再进行修改，否则不修改并返回失败。
> 整个比较并替换的操作是一个原子操作。

CAS本身操作的原子性保证
> 通过`循环CAS法`保证CAS是一个原子性操作。这里的CAS是指Unsafe中的CAS方法。很多CAS操作都是依赖Unsafe类完成。
> Unsafe中应用了循环CAS法。并且Unsafe的方法基本都是native方法。这些底层方法执行过程中在会被处理器添加Lock前缀(指
> 令的Lock前缀作用参考volatile)。总结：[Unsafe + 循环CAS + Lock前缀]

##### CAS会产生什么问题
> 1、ABA问题：“如果一个值原来是A，后来修改成了B，然后又修改回为A。这时CAS就会认为它从来没有被改变过。可是实际上确实发生
> 了改变”，这一漏洞称之为“ABA问题”。`解决办法：---添加版本号。`如添加版本后：那么A -B -A就会变成1A -2B -3A。只有
> 版本号预期与预期值都相同时，认为成功。
> 
> 循环时间长开销大：自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。   
> 
> 只能保证一个共享变量的原子操作：循环CAS的方式只能保证一个变量原子操作，当多个变量时可以`加锁`。甚至将多个变量当成一
> 个变量实现。

##### notify和notifyAll区别,锁池,等待池
> 等待池：线程调用了某个对象的wait()方法后，线程就会释放该对象的锁，然后进入到了该对象的等待池，等待池中的线程不会去竞
> 争该对象的锁。(释放了锁的线程)

> 锁池：线程去竞争已被获取了锁的对象时，线程就会进入到该对象的锁池。(等待竞争锁的线程)

> notify()：随机唤醒对象的等待池中的`一个线程`，进入锁池
> notifyAll()：唤醒对象的等待池中的`所有线程`，进入锁池


### 6、加密

##### 有用过什么加密算法？AES,RAS什么原理？
##### 对称加密和非对称加密，说说公钥


### 7、反射

##### 反射的作用与原理。
##### 什么是反射。
##### 反射可以反射final修饰的字段吗
##### 反射是什么，在哪里用到，怎么利用反射创建一个对象。
##### 反射机制的优缺点
##### Class.getField和getDeclaredField的区别，getDeclaredMethod和getMethod的区别


### 8、jvm

##### 说说 JVM 运行时数据区
##### 说说 JVM 内存区域
##### Java 对象如何创建的，对象创建过程
##### 对象加载的过程，属性先加载还是方法先加载
##### PathClassLoader与DexClassLoader有什么区别
##### Jvm的内存结构，Jvm的垃圾回收，方法区有什么东西
##### 拉圾回收的GCRoot是什么
##### 说说Java的内存分区
##### 讲讲你对垃圾回收机制的了解，老年代有什么算法？
##### JVM类加载机制了解吗，类什么时候会被加载？类加载的过程具体生命周期是怎样的？
##### Jvm的内存模型,每个里面都保存的什么
##### 类加载机制的几个阶段加载、验证、准备、解析、初始化、使用、卸载
##### 对象实例化时的顺序
##### 类加载器,双亲委派及其优势
##### 垃圾回收机制
##### 程序计数器为什么设计成私有
##### 虚拟机栈和本地方法栈为什么设计成私有
##### String.intern() 作用
##### 虚拟机如何解决内存分配并发问题
##### 内存分配策略
##### 对象的访问定位有哪几种
##### GC原理，有哪几种GC方式
##### VM的分区，各个分区的作用