
### 1、基础知识

##### 说说  ==、equals 和 hashcode
简单说说，无非是什么，有什么用，有什么区别。参考回答：
> 它们都是用来判断对象是否相等。
> 不同点：`双等号(==)`对于基本数据类型，只要它们的值相同，结果就是true，否则false。对于非基本数据类型对象，是判断
> 是否为同一个内存地址，同一个引用；`equals`是Object中的方法，并且Object中equals默认使用==来判断，判断内容是否相
> 同，也就是值比较，==是引用比较；  
> equals与hashcode也是比较2个对象内容是否相等，并且都是Object中的方法。如果2个对象相等，hashcode一定相等，equals
> 也是返回true；如果只有equals相等，2个对象也是相等，它们的hashCode()也一定相等；如果只有hashcode相等，2个对象不
> 一定相等，equal也不一定相等。equal对应是准确性，hashcode对应是效率。

##### 为什么有了equals(hashcode)还要hashcode(equals)。
> 因为重写equal比较全面、复杂，效率就变低，而利用hashCode进行对比，只要生成一个hash值进行比较就可以，效率比较高。 
> 
> 因为hashCode并不完全可靠，有时候不同的对象他们生成的hashcode也会一样。(java中的hash函数返回的是int类型，对于
> hashcode的计算也是有限的，数据量大就有可能出现相同的hash值)

##### equals 和 hashcode如何协调比较。
> 当需要对比的时候，首先用hashCode去对比，如果hashCode不一样，则表示这两个对象肯定不相等，就不必再用equal去比较；
> 如果hashCode()相同，再对比他们的equal()。如果equal()也相同，则表示这两个对象是相同的。这样既能提高效率也能
> 保证准确性。

##### equals、hashcode为什么必须重写,只重写一个会怎样。
只重写一个无法保证准确性，无法满足所有需求，还会引发其他错误。
> 只重写equal，那么2个对象比较的就是hashcode，这个值是由内存地址转化而来，不同对象一定不同。这会导致创建的2个对象所
> 有属性都相同，但是因为hashcode没有重写，程序识别为2个不同的对象。即是equals相等了，hashcode也不等，违反hashcode
> 规则。  
> 只重写hashcode，那么比较的其实是对象的地址值(equals默认==实现)，不同对象也一定不同，甚至可以说2个对象永远不会相
> 等；

##### HashMap和HashSet为什么必须同时重写hashcode和equals。
> 一是hashcode和equals只重写其中一个都无法保证HashMap与HashSet内元素的准确性，就是无法判断2个对象是否相等；   
> 二会导致hash容器无法正常工作。(hash表是以key-value保存数据，key就是根据对象hashcode计算而来：
> 计算key下标的方式：(n - 1) & hash，n是数组长度。只重写equals会导致hashcode出现相同，导致无法保证key的唯一性)；
> 只重写hashcode会导致2个不同对象会被挂载到同一个key上，后挂载的会替换前挂载的，导致使用key获取的不是同一个对象。)

##### HashCode的作用
> 对象区别于其他对象的标识,hashcode是当前对象的地址值计算转化来的。

##### Switch能否用string做参数
> Java 1.7之前只能支持byte、short、int、char或其封装类及enum类型，1.7及以上才支持string，boolean类型也是不支持

##### java基本数据类型有哪些，int，long占几个字节
> 4类8种。
> 整数类(byte[1个字节，-128~127]、short[2个字节，-32768~32767]、int[4个字节，-2的31次方~2的31次方-1，约21亿]、
> long[8个字节])；   
> 浮点类(float[4个字节]、double[8个字节])、   
> 字符类(char[2个字节])、  
> 布尔类(boolean[占1位]);除此外都是引用数剧类型。  

##### Java面向对象的三个特征与含义。
> 封装：把客观事物封装成类或对象，隐藏对象的属性和实现细节，对外提供接口访问；   
> 继承：让某个类型的对象获得另一个类型的对象的属性和方法。继承导致类之间有分等级层次，子类可以继承父类的特征和行为，使
> 得子类具有父类相同的属性和行为；   
> 多态：同一个行为，不同的子类对象具有不同的表现形式。只有在运行的时候才知道引用指向的是哪个类的实例对象，以及引用调
> 用的方法指向的是哪个类中实现的方法。比如`重载`跟`重写(覆盖)`，父类引用指向子类实例等等。

##### java有什么特性，继承有什么用处，多态有什么用处。
> 封装：对内部数据提供了不同级别的保护，代码重用；
> 继承：扩展已存在的类或对象，代码重用；
> 多态：增加类或对象使用的灵活性和扩展性；

##### java为什么能做到多态
> 只有在运行的时候才知道引用指向的是哪个类的实例对象，以及引用调用的方法指向的是哪个类中实现的方法(运行时类型判定)。
> 因为    
> 1、类之间的继承关系。  
> 2、方法的重载跟重写。   
如果子类改写了父类的方法，那么子类和父类的同名方法共享一个方法表项，都被认作是父类的方法。在调用子类方法时，通过解析子
类实例方法获取对应方法表中的偏移量，通过偏移量找到实际的方法。

##### Override和Overload的含义去区别。
> Override：重写/覆盖。方法名、参数、返回值与父类完全相同。存在与父类子类之间；   
> overload：重载。方法参数的类型、个数、顺序至少有一个不相同。存在同个类的方法与方法之间；

##### String s = new String("xx")创建了几个对象
> 1个或者2个。如果常量池存在"xx",就是创建了1个，如果常量池不存在"xx",就是2个(引用对象s不算)。

##### String是最基本的数据类型吗
> 不是。

##### 是否可以继承String类
> 不能，String是final修饰的，实现细节不允许改变。

##### 为什么final不能被继承
> 在java中，final关键字是“这是无法改变的”或者“终态的”含义。规定无法被它修饰的类无法继承，可能是出于设计或者效率。

##### String、StringBuffer与StringBuilder的区别。
都可以用来表示字符串。
> String是固定长度字符串，即是有拼接操作也是返回创建新的字符串对象；而StringBuffer与StringBuilder是可变字符串，
> 可以在原对象基础上拼接，对象不会改变(原因是它们内部使用char数组拼接处理)；所以String做拼接效率很低。String适用于
> 少量的字符串操作，StringBuffer与StringBuilder适用于大量字符串操作。    
> StringBuilder是线程不安全的，单线程环境表现突出。StringBuffer是线程安全的，多线程环境下表现突出。(内部的char数
> 组基础容量是16，每次扩容为增加原来一倍+2)

##### &和&&的区别？
> & 属于位运算，按位与，&&属于逻辑运算，逻辑与。   
> &&有短路功能，即第一个表达式为false时，整个结果就是false，不再判断第二个表达式；&没有短路功能

##### 值传递与引用传递？java是引用传递还是值传递
值传递和引用传递的区别并不是传递的内容，而是实参到底有没有被复制一份给形参。
> 值传递：复制一份变量传递给其他变量，在方法中修改并不会改变原始变量的值；引用传递：直接传递对象的地址，修改会改变对象
> 本身的值。    
> java是值传递，没有引用传递。对于基本数据类型，是传递对象量值的副本；对于引用类型，是该对象在内存中的地址值的副本。

##### int和Integer区别
> Integer是int的包装类；int是基本数据类型;   
> Integer变量必须实例化后才可以使用，而int变量则不需要;  
> Integer的默认值是null，而int的默认值为0.

##### char类型变量中能不能存贮一个中文汉字
> 可以。char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含汉字。如果某个汉字没有被包含在unicode编码
> 字符集中，那么这个char型变量就不能存储这个汉字。unicode编码占用两个字节；char类型的变量也是占用两个字节。

##### try catch finally，try里有return，finally还执行么
> 会执行。但是finally无法改变返回值。因为在执行的过程中, 如果try执行到return,会先将结果保存在一个临时变量中,等
> 到finally执行完毕之后再将保存的值取出返回。

##### java中静态方法，能不能被子类重写？编译会报错么
> 不能重写。静态方法只与类有关系，跟实例对象没有关系。重写是为了多态，静态方法在加载时就绑定了类，不存在父类引用指向子
> 类实例，也就不存在多态。但是子类可以声明与父类相同参数，同名的静态方法，但是这个类是绑定子类的，不能加重写注解。

##### 在一个静态方法内调用一个非静态成员为什么是非法的？
> 静态方法是跟随类的，随类的加载而加载；而非静态方法属性是属于对象的，对象是在类加载完后创建生成的。对象没有生成，非静
> 态成员当然也不存在。只依赖于类而不依赖于对象的静态方法自然不能调用一个不存在的方法，也不知道哪个对象，哪个成语变量。

##### 静态类与非静态类的区别。
> java中，静态类只能是内部类，因为外部类无法用static修饰。
> 看下面内部类特点。

##### 匿名内部类的特点
> 匿名内部类可以访问外部内的所有成员，外部类不能访问内部类的属性、方法   
> 匿名内部类不能访问外部类未加final修饰的变量(jdk1.8即使没有用final修饰也可以访问)   
> 匿名内部类中不能定义静态属性、方法   
> 内部类的隐藏属性this、super都是指向内部类自己。

##### 匿名内部类能不能访问外部类的私有方法(属性)？为什么
> 可以。内部类总有一个隐式引用指向外部类，在编译过程中，编译器会为外部类的私有属性生成静态方法。

##### 匿名内部类编译后也是独立的外部类，它为何能访问外部类的私有方法？如果能访问，怎么做到的？
> 内部类总有一个隐式引用指向外部类，在编译过程中，编译器会为外部类的私有属性生成相应的静态方法。

##### foreach与正常for循环效率对比。
> foreach效率更高。foreach只能用于遍历，不能更改循环目标，遍历速度快，执行效率高。for循环可以用于任何形式的重复行
> 为，在循环体中可以进行任何操作，所以遍历速度慢，执行效率低。

##### 装箱和拆箱的原理
> 装箱：自动将基本数据类型转换为包装器类型，调用`valueOf()`完成装箱；    
> 拆箱：自动将包装器类型转换为基本数据类型，调用了`***Value()`完成拆箱；   

### 2、数据结构、集合容器

##### ArrayList、LinkedList、Vector的区别
> ArrayList：使用可变数组实现，可以添加任何元素，包括null；  
> Vector：几乎与ArrayList一样，但是Vector是线程安全的；  
> LinkedList：双向链表实现，可以添加任何元素，包括null；

##### Map、Set、List、Queue、Stack 的特点与用法。
> Map：以key-value键值对结构存储元素；key唯一，value可以重复；元素可以无序(hashMap)，也可以有序(LinkedHashMap)   
> List：保存元素有序；允许重复元素，可以通过下标访问元素；   
> Set：保存元素元素唯一，可以排序(treeSet)；  
> Queue：先进先出；
> Stack：先进后出；

##### ArrayList扩容机制？
> 初始容量为10，扩容因子为1.5，即扩容后容量是原容量的1.5倍，计算方式为`new = old + (old >> 1)`。当数组的长度小
> 于最小需要的容量(当前元素容量+待添加的元素数量)就扩容。

##### 为什么ArrayList扩容因子是1.5
> 首先扩容容量不能太小，防止频繁扩容，数组频繁复制；第二，扩容容量不能太大，需要充分利用空间，避免浪费过多空间；还有就是
> 计算尽量高效，使用位运算的计算效率是比较高的。

##### 链表的查找的时间复杂度是多少
> O(n)，因为链表始终需要按照顺序一个一个查找对比。

##### TreeMap、HashMap、LinkedHashMap的区别。
> HashMap：根据key的HashCode值存储数据，有很快的访问速度，取出的数据的顺序是随机的
> LinkedHashMap：内部有双向链表，存取元素时有序的(保存顺序与取出顺序一样)；
> TreeMap：基于红黑树实现，具有排序功能,默认是自然排序(升序)

##### 讲讲LinkedHashMap的数据结构，实现按顺序存取的原理。
> 继承HashMap，实现Map接口。内部维护代表链表头尾节点的两个对象，并且重写HashMap创建节点的方法，在调用父类put()添加
> 元素创建节点时，控制头尾结点，完成链表元素添加。当删除元素时也是先删除hash表上的元素，然后再通过重写方法移除节点。

##### HashMap和HashTable的区别。
--  |  HashMap  |   HashTable
:--- | :--- | :----
多线程问题 | 线程不安全、效率高 | 线程安全、效率低
底层结构 |  数组+链表 + 红黑树(jdk1.8后) | 数组+链表
扩容方面 | 初始容量大小为16，扩容后变为原来的2倍 | 初始容量大小为11，扩容后会变为2n+1
继承关系 | AbstractMap | Dictionary(被废弃)

##### HashTable为何废弃
> 线程安全形成效率低下；HashTable继承的父类也是被废弃了。

##### ConcurrentHashMap
产生原因、区分jdk7跟jdk8的区别
> 因为HashMap是非线程安全的，在并发情况下存在很大的隐患(多线程扩容时，链表可能会出现死循环)；HashTable虽然是线程安
> 全的，但是因为它所有的get/put都添加了synchronized，导致性能非常差。于是ConcurrentHashMap便出现了。    

jdk1.7版本：
> 底层数据结构是数组和链表。但是与HashMap不同的是引入了一个`Segment`的东西。Segment本身就像是一个HashMap，还继承
> ReentrantLock。HashMap的底层结构是个Entry数组，里面的元素是一个链表的表头，而ConcurrentHashMap的底层结构是
> Segment数组，每个Segment包含一个Entry数组，每个元素都是一个链表的表头。像个二级HashMap。
> 
> 结构好处：使用分段锁技术，实现真正的并发。[多线程环境下，不同Segment之间读写互不影响；同一个Segment下的读取、一读
> 一写也能并发执行，写入并发时需要获取锁，否则阻塞。]坏处是查找过程要比普通的HashMap要长。      
> 
> 查找数据：需要进过2次查找，第一次定位到Segment，第二次定位到元素所在Segment内部数组元素，也就是对应链表的表头。  
> 
> 统计元素size：首先遍历所有的Segment，统计元素数量以及发生修改次数。当修改总数与上次统计一样时，说明没有修改，当前
> 统计的数量就是map内的总数量，统计结束；当不一样时，重新统计，统计计数器+1。当统计次数到一定数量(3次)时，对每个
> Segment加锁，再次统计，最后返回总数(加锁后无法再修改，所以前后修改次数是相同的)。     
> 原因：上来就直接锁住所有Segment，统计完再解锁。这样做会影响到Map的其他读写操作，不利于并行。

jdk1.8：
> 底层数据结构：为了提高并发性，放弃分段锁的方案；采用数组+链表+红黑树的数据结构，与HashMap一样。采用CAS+
> synchronized保证线程安全

##### HashMap和ConcurrentHashMap的区别
> 最大区别就是HashMap线程不安全、ConcurrentHashMap线程安全。

##### 说说HashMap的原理
> HashMap是基于数组+链表结构设计的。数组中的每个元素都是一条链表的表头。数组默认长度为16。添加元素时，根据key的hash
> 值与数组长度-1,做与运算，得到元素在数组中的位置。如果数组对应索引存在元素并且它们的hash值不一样，就将新元素添加到后
> 面(尾插法，jdk1.7是头插法)成为该链表的一个新节点。jdk1.8后，引入红黑树，当hash数组的容量大于64且链表长度大于8时，
> 链表转红黑树；当长度小于6的时，红黑树转链表。

##### HashMap中hash函数怎么实现的，还有哪些hash函数的实现方式
> 首先获取到key的hashcode值， 然后让hashcode值的高16位和低16位进行异或操作。目的是为了降低哈希碰撞的概率。

##### HashMap中get()、put()如何实现的
put：
> 1、计算key的hash值；   
> 2、计算key在数组中的索引(hash&(arr.length-1)；   
> 3、如果当前索引对应的数组元素为null，直接在该索引上，充当链表头几点；如果不为null，比较key的hash值或者equals，
> 有一个不同时将新元素插入到链表成为新节点；如果都hash值跟equals都相等，替换value。

get:
> 1、计算key的hash值；   
> 2、计算key在数组中的索引(hash&(arr.length-1)；    
> 3、key的hash值判断，如果是链表头节点则返回头结点；如果不是，判断表头节点是否属于红黑树。如果是，遍历红黑树查找
> 到目标，否则遍历链表找到指定元素。

##### hashmap扩容是怎么做的，怎么处理hash冲突
> 当元素数量超过阈值时便会触发扩容。每次扩容的容量都是之前容量的2倍。[阈值 = 数组容量 * 负载因子]。默认初始容量为16，
> 负载因子为0.75。

解决hash冲突：
> 1、链式地址法。在冲突的位置拉一个链表，把冲突的元素放进去。(数组+链表结构)
> 2、扰动函数。(hash函数[哈希值的高16位^哈希值的低16位])。(从哈希值入手，尽可能保证哈希值不一样)
> 3、引入红黑树。(优化Hash表链表过长导致时间复杂度增加)
> 4、再Hash法(未使用)。利用多个hash函数，遇到冲突时就使用其他hash函数计算，直到不冲突。(缺点：计算时长增加)

##### 当两个对象的hashCode相等时会怎样
> 发生哈希冲突，若key值内容相同则替换旧的value，否则添加到链表后面，当链表长度超过阈值8，并且数组长度大于64就转为
> 红黑树存储。

##### hashmap扩容会有什么问题吗
> 链表可能会出现死循环。原因：多线程环境 + 链表头插法(jdk1.7为头插法，1.8后变成尾插法)
> <https://www.cnblogs.com/zhuoqingsen/p/8577646.html>

##### HashMap查找的时间复杂度是多少？
> 找表头元素是O(1)，因为数组的索引指定查找；链表时O(n)，红黑树时O(logN)

##### 为什么HashMap初始大小是2的次幂
> 为了尽量将集合元素均摊到数组的不同位置上

##### HashMap的数据结构,如何保证快速查找,容量为何要设计为2的n次方这样？对扩容有没有影响？
##### Hashmap如何解决散列碰撞
##### Hashmap底层为什么是线程不安全的
##### 解决hash冲突的时候，为什么用红黑树
##### 红黑树的效率高，为什么一开始不用红黑树存储
##### 为什么阀值是8才转为红黑树
##### 为什么退化为链表的阈值是6
##### 二分搜索树的特性和原理
##### 堆的实现，最大堆，最小堆，优先队列原理
##### Comparable 和 Comparator 的区别
##### LRU实现
##### ArrayMap 和 SparseArray


### 3、泛型

##### 泛型常用特点，List<String>能否转为List<Object>。
##### 泛型是怎么解析的，比如在retrofit中的泛型是怎么解析的
##### 泛型有什么优点
##### 泛型为什么要擦除？kotlin的泛型了解吗？泛型的pecs原则
##### 为何会有协变和逆变
##### 通配符


### 4、线程、多线程、线程池、同步

##### 实现多线程的两种方法。
> Thread与Runnable。

##### 多线程存在哪些问题
##### 线程池核心参数
##### 并发和并行区别
##### 线程的几种状态
##### 创建线程的几种方式
##### ThreadLocal的设计理念与作用。
##### ThreadPool用法与优势。
##### 谈谈线程死锁，如何有效的避免线程死锁？
##### 如何让两个线程循环交替打印
##### 三个线程依次打印，有哪些方式
##### 如何实现多线程中的同步
##### 线程间同步的方法
##### 怎么中止一个线程，Thread.Interrupt一定有效吗
##### 为什么用线程池
##### 线程池了解多少？拒绝策略有几种,为什么有newSingleThread
##### wait()和sleep()的区别
##### synchronized和Lock的使用、区别,原理；
##### 为什么会有线程安全？如何保证线程安全
##### interrupt()、interrupted()、isInterrupted() 区别
##### start()、run() 区别
##### 何为阻塞队列？
##### volatile，synchronized和volatile的区别？为何不用volatile替代synchronized？
##### 如何配置线程池的？核心线程数你一般是怎么配置的
##### AtomicInteger如何保证原子操作
##### CAS如何保证原子操作


### 5、锁

##### 平常有用到什么锁，synchronized底层原理是什么 
##### synchronized是公平锁还是非公平锁,ReteranLock是公平锁吗？是怎么实现的
##### 锁之间的区别，同步锁举例
##### 对volatile字段有什么用途？
##### JMM可见性，原子性，有序性，synchronized可以保证什么
##### 锁的分类，锁的几种状态，CAS原理
##### AQS了解吗？
##### 如何避免死锁
##### 公平锁、非公平锁、可重入锁
##### sleep()与wait()区别,run和start的区别,notify和notifyall区别,锁池,等待池


### 6、加密

##### 有用过什么加密算法？AES,RAS什么原理？
##### 对称加密和非对称加密，说说公钥


### 7、反射

##### 反射的作用与原理。
##### 什么是反射。
##### 反射可以反射final修饰的字段吗
##### 反射是什么，在哪里用到，怎么利用反射创建一个对象。
##### 反射机制的优缺点
##### Class.getField和getDeclaredField的区别，getDeclaredMethod和getMethod的区别


### 8、jvm

##### 说说 JVM 运行时数据区
##### 说说 JVM 内存区域
##### Java 对象如何创建的，对象创建过程
##### 对象加载的过程，属性先加载还是方法先加载
##### PathClassLoader与DexClassLoader有什么区别
##### Jvm的内存结构，Jvm的垃圾回收，方法区有什么东西
##### 拉圾回收的GCRoot是什么
##### 说说Java的内存分区
##### 讲讲你对垃圾回收机制的了解，老年代有什么算法？
##### JVM类加载机制了解吗，类什么时候会被加载？类加载的过程具体生命周期是怎样的？
##### Jvm的内存模型,每个里面都保存的什么
##### 类加载机制的几个阶段加载、验证、准备、解析、初始化、使用、卸载
##### 对象实例化时的顺序
##### 类加载器,双亲委派及其优势
##### 垃圾回收机制
##### 程序计数器为什么设计成私有
##### 虚拟机栈和本地方法栈为什么设计成私有
##### String.intern() 作用
##### 虚拟机如何解决内存分配并发问题
##### 内存分配策略
##### 对象的访问定位有哪几种
##### GC原理，有哪几种GC方式
##### VM的分区，各个分区的作用